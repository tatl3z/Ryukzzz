{"version":3,"names":["_gensync","data","require","_functional","_index","_item","_caching","_resolveTargets","isEqualDescriptor","a","b","_a$file","_b$file","_a$file2","_b$file2","name","value","options","dirname","alias","ownPass","file","request","resolved","handlerOf","optionsWithResolvedBrowserslistConfigFile","browserslistConfigFile","resolveBrowserslistConfigFile","createCachedDescriptors","plugins","presets","passPerPreset","createCachedPluginDescriptors","createCachedPresetDescriptors","createUncachedDescriptors","once","createPluginDescriptors","createPresetDescriptors","PRESET_DESCRIPTOR_CACHE","WeakMap","makeWeakCacheSync","items","cache","using","dir","makeStrongCacheSync","makeStrongCache","descriptors","map","desc","loadCachedDescriptor","PLUGIN_DESCRIPTOR_CACHE","DEFAULT_OPTIONS","cacheByOptions","get","set","possibilities","includes","matches","filter","possibility","length","push","createDescriptors","type","gensync","all","item","index","createDescriptor","assertNoDuplicates","pair","getItemDescriptor","Array","isArray","undefined","filepath","Error","resolver","loadPlugin","loadPreset","String","__esModule","default","Map","nameMap","Set","has","conflicts","i","JSON","stringify","join","add"],"sources":["../../src/config/config-descriptors.ts"],"sourcesContent":["import gensync, { type Handler } from \"gensync\";\nimport { once } from \"../gensync-utils/functional.ts\";\n\nimport { loadPlugin, loadPreset } from \"./files/index.ts\";\n\nimport { getItemDescriptor } from \"./item.ts\";\n\nimport {\n  makeWeakCacheSync,\n  makeStrongCacheSync,\n  makeStrongCache,\n} from \"./caching.ts\";\nimport type { CacheConfigurator } from \"./caching.ts\";\n\nimport type {\n  ValidatedOptions,\n  PluginList,\n  PluginItem,\n} from \"./validation/options.ts\";\n\nimport { resolveBrowserslistConfigFile } from \"./resolve-targets.ts\";\nimport type { PluginAPI, PresetAPI } from \"./helpers/config-api.ts\";\n\n// Represents a config object and functions to lazily load the descriptors\n// for the plugins and presets so we don't load the plugins/presets unless\n// the options object actually ends up being applicable.\nexport type OptionsAndDescriptors = {\n  options: ValidatedOptions;\n  plugins: () => Handler<Array<UnloadedDescriptor<PluginAPI>>>;\n  presets: () => Handler<Array<UnloadedDescriptor<PresetAPI>>>;\n};\n\n// Represents a plugin or presets at a given location in a config object.\n// At this point these have been resolved to a specific object or function,\n// but have not yet been executed to call functions with options.\nexport interface UnloadedDescriptor<API, Options = object | undefined | false> {\n  name: string | undefined;\n  value: object | ((api: API, options: Options, dirname: string) => unknown);\n  options: Options;\n  dirname: string;\n  alias: string;\n  ownPass?: boolean;\n  file?: {\n    request: string;\n    resolved: string;\n  };\n}\n\nfunction isEqualDescriptor<API>(\n  a: UnloadedDescriptor<API>,\n  b: UnloadedDescriptor<API>,\n): boolean {\n  return (\n    a.name === b.name &&\n    a.value === b.value &&\n    a.options === b.options &&\n    a.dirname === b.dirname &&\n    a.alias === b.alias &&\n    a.ownPass === b.ownPass &&\n    a.file?.request === b.file?.request &&\n    a.file?.resolved === b.file?.resolved\n  );\n}\n\nexport type ValidatedFile = {\n  filepath: string;\n  dirname: string;\n  options: ValidatedOptions;\n};\n\n// eslint-disable-next-line require-yield\nfunction* handlerOf<T>(value: T): Handler<T> {\n  return value;\n}\n\nfunction optionsWithResolvedBrowserslistConfigFile(\n  options: ValidatedOptions,\n  dirname: string,\n): ValidatedOptions {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = resolveBrowserslistConfigFile(\n      options.browserslistConfigFile,\n      dirname,\n    );\n  }\n  return options;\n}\n\n/**\n * Create a set of descriptors from a given options object, preserving\n * descriptor identity based on the identity of the plugin/preset arrays\n * themselves, and potentially on the identity of the plugins/presets + options.\n */\nexport function createCachedDescriptors(\n  dirname: string,\n  options: ValidatedOptions,\n  alias: string,\n): OptionsAndDescriptors {\n  const { plugins, presets, passPerPreset } = options;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins\n      ? () =>\n          // @ts-expect-error todo(flow->ts) ts complains about incorrect arguments\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          createCachedPluginDescriptors(plugins, dirname)(alias)\n      : () => handlerOf([]),\n    presets: presets\n      ? () =>\n          // @ts-expect-error todo(flow->ts) ts complains about incorrect arguments\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          createCachedPresetDescriptors(presets, dirname)(alias)(\n            !!passPerPreset,\n          )\n      : () => handlerOf([]),\n  };\n}\n\n/**\n * Create a set of descriptors from a given options object, with consistent\n * identity for the descriptors, but not caching based on any specific identity.\n */\nexport function createUncachedDescriptors(\n  dirname: string,\n  options: ValidatedOptions,\n  alias: string,\n): OptionsAndDescriptors {\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    // The returned result here is cached to represent a config object in\n    // memory, so we build and memoize the descriptors to ensure the same\n    // values are returned consistently.\n    plugins: once(() =>\n      createPluginDescriptors(options.plugins || [], dirname, alias),\n    ),\n    presets: once(() =>\n      createPresetDescriptors(\n        options.presets || [],\n        dirname,\n        alias,\n        !!options.passPerPreset,\n      ),\n    ),\n  };\n}\n\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = makeWeakCacheSync(\n  (items: PluginList, cache: CacheConfigurator<string>) => {\n    const dirname = cache.using(dir => dir);\n    return makeStrongCacheSync((alias: string) =>\n      makeStrongCache(function* (\n        passPerPreset: boolean,\n      ): Handler<Array<UnloadedDescriptor<PresetAPI>>> {\n        const descriptors = yield* createPresetDescriptors(\n          items,\n          dirname,\n          alias,\n          passPerPreset,\n        );\n        return descriptors.map(\n          // Items are cached using the overall preset array identity when\n          // possibly, but individual descriptors are also cached if a match\n          // can be found in the previously-used descriptor lists.\n          desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc),\n        );\n      }),\n    );\n  },\n);\n\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = makeWeakCacheSync(\n  (items: PluginList, cache: CacheConfigurator<string>) => {\n    const dirname = cache.using(dir => dir);\n    return makeStrongCache(function* (\n      alias: string,\n    ): Handler<Array<UnloadedDescriptor<PluginAPI>>> {\n      const descriptors = yield* createPluginDescriptors(items, dirname, alias);\n      return descriptors.map(\n        // Items are cached using the overall plugin array identity when\n        // possibly, but individual descriptors are also cached if a match\n        // can be found in the previously-used descriptor lists.\n        desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc),\n      );\n    });\n  },\n);\n\n/**\n * When no options object is given in a descriptor, this object is used\n * as a WeakMap key in order to have consistent identity.\n */\nconst DEFAULT_OPTIONS = {};\n\n/**\n * Given the cache and a descriptor, returns a matching descriptor from the\n * cache, or else returns the input descriptor and adds it to the cache for\n * next time.\n */\nfunction loadCachedDescriptor<API>(\n  cache: WeakMap<\n    object | Function,\n    WeakMap<object, Array<UnloadedDescriptor<API>>>\n  >,\n  desc: UnloadedDescriptor<API>,\n) {\n  const { value, options = DEFAULT_OPTIONS } = desc;\n  if (options === false) return desc;\n\n  let cacheByOptions = cache.get(value);\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  let possibilities = cacheByOptions.get(options);\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (!possibilities.includes(desc)) {\n    const matches = possibilities.filter(possibility =>\n      isEqualDescriptor(possibility, desc),\n    );\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction* createPresetDescriptors(\n  items: PluginList,\n  dirname: string,\n  alias: string,\n  passPerPreset: boolean,\n): Handler<Array<UnloadedDescriptor<PresetAPI>>> {\n  return yield* createDescriptors(\n    \"preset\",\n    items,\n    dirname,\n    alias,\n    passPerPreset,\n  );\n}\n\nfunction* createPluginDescriptors(\n  items: PluginList,\n  dirname: string,\n  alias: string,\n): Handler<Array<UnloadedDescriptor<PluginAPI>>> {\n  return yield* createDescriptors(\"plugin\", items, dirname, alias);\n}\n\nfunction* createDescriptors<API>(\n  type: \"plugin\" | \"preset\",\n  items: PluginList,\n  dirname: string,\n  alias: string,\n  ownPass?: boolean,\n): Handler<Array<UnloadedDescriptor<API>>> {\n  const descriptors = yield* gensync.all(\n    items.map((item, index) =>\n      createDescriptor(item, dirname, {\n        type,\n        alias: `${alias}$${index}`,\n        ownPass: !!ownPass,\n      }),\n    ),\n  );\n\n  assertNoDuplicates(descriptors);\n\n  return descriptors;\n}\n\n/**\n * Given a plugin/preset item, resolve it into a standard format.\n */\nexport function* createDescriptor<API>(\n  pair: PluginItem,\n  dirname: string,\n  {\n    type,\n    alias,\n    ownPass,\n  }: {\n    type?: \"plugin\" | \"preset\";\n    alias: string;\n    ownPass?: boolean;\n  },\n): Handler<UnloadedDescriptor<API>> {\n  const desc = getItemDescriptor(pair);\n  if (desc) {\n    return desc;\n  }\n\n  let name;\n  let options;\n  // todo(flow->ts) better type annotation\n  let value: any = pair;\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n\n  let file = undefined;\n  let filepath = null;\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\n        \"To resolve a string-based item, the type of item must be given\",\n      );\n    }\n    const resolver = type === \"plugin\" ? loadPlugin : loadPreset;\n    const request = value;\n\n    ({ filepath, value } = yield* resolver(value, dirname));\n\n    file = {\n      request,\n      resolved: filepath,\n    };\n  }\n\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(\n      `Unsupported format: ${typeof value}. Expected an object or a function.`,\n    );\n  }\n\n  if (filepath !== null && typeof value === \"object\" && value) {\n    // We allow object values for plugins/presets nested directly within a\n    // config object, because it can be useful to define them in nested\n    // configuration contexts.\n    throw new Error(\n      `Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`,\n    );\n  }\n\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file,\n  };\n}\n\nfunction assertNoDuplicates<API>(items: Array<UnloadedDescriptor<API>>): void {\n  const map = new Map();\n\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n\n    let nameMap = map.get(item.value);\n    if (!nameMap) {\n      nameMap = new Set();\n    €          Threading       ğÿÿÿ(úaPúaˆúahbin pa                       Øÿÿÿvk
   €          TrustLevel      Xÿÿÿnk  åŞä¸ÃŠÚ   Àó\        ÿÿÿÿÿÿÿÿ   qağ‚  ÿÿÿÿ           @       Q   Windows.ApplicationModel.CommunicationBlocking.CommunicationBlockingAccessManager       Øÿÿÿvk   €          ActivationType  èÿÿÿğpa0qa˜qaÀqa    àÿÿÿvk @   Pqa      DllPath ¸ÿÿÿC : \ W i n d o w s \ S y s t e m 3 2 \ P h o n e O m . d l l       Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      `ÿÿÿnk  åŞä¸ÃŠÚ   Àó\        ÿÿÿÿÿÿÿÿ   °rağ‚  ÿÿÿÿ           @       N   Windows.ApplicationModel.CommunicationBlocking.CommunicationBlockingAppManager  Øÿÿÿvk   €          ActivationType  èÿÿÿˆraÈra0saXsa    àÿÿÿvk @   èra      DllPath ¸ÿÿÿC : \ W i n d o w s \ S y s t e m 3 2 \ P h o n e O m . d l l       Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      pÿÿÿnk  åŞä¸ÃŠÚ   Àó\        ÿÿÿÿÿÿÿÿ   8tağ‚  ÿÿÿÿ           P       ;   Windows.ApplicationModel.ComponentUI.ComponentLaunchOptions§áıÜØÿÿÿvk   €          ActivationType  èÿÿÿtaPtaÈtağta    àÿÿÿvk P   pta      DllPath ¨ÿÿÿC : \ W i n d o w s \ S y s t e m 3 2 \ t w i n a p i . a p p c o r e . d l l       Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      xÿÿÿnk  åŞä¸ÃŠÚ   Àó\        ÿÿÿÿÿÿÿÿ   Èuağ‚  ÿÿÿÿ           P       5   Windows.ApplicationModel.ComponentUI.ComponentManagerõuØÿÿÿvk   €          ActivationType  èÿÿÿ uaàuaXva€va    àÿÿÿvk P    va      DllPath ¨ÿÿÿC : \ W i n d o w s \ S y s t e m 3 2 \ t w i n a p i . a p p c o r e . d l l       Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   Pwağ‚  ÿÿÿÿ           L       )   Windows.ApplicationModel.Contacts.Contactô­CÊG°Øÿÿÿvk   €          ActivationType  èÿÿÿ(wahwaØwa xa    àÿÿÿvk L   ˆwa      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   Ğxağ‚  ÿÿÿÿ           L       0   Windows.ApplicationModel.Contacts.ContactAddressØÿÿÿvk   €          ActivationType  èÿÿÿ¨xaèxaXya€ya    àÿÿÿvk L   ya      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      xÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   Xzağ‚  ÿÿÿÿ           L       3   Windows.ApplicationModel.Contacts.ContactAnnotationëØÿÿÿvk   €          ActivationType  èÿÿÿ0zapzaàza{a    àÿÿÿvk L   za      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      xÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   à{ağ‚  ÿÿÿÿ           L       4   Windows.ApplicationModel.Contacts.ContactCardOptionsÁÌ*îØÿÿÿvk   €          ActivationType  èÿÿÿ¸{aø{ah|a|a    àÿÿÿvk L   |a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      pÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   p}ağ‚  ÿÿÿÿ           L       @   Windows.ApplicationModel.Contacts.ContactConnectedServiceAccountØÿÿÿvk   €          ActivationType  èÿÿÿH}aˆ}aø}a ~a    àÿÿÿvk L   ¨}a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   ğ~ağ‚  ÿÿÿÿ           L       -   Windows.ApplicationModel.Contacts.ContactDateÕsIØÿÿÿvk   €          ActivationType  èÿÿÿÈ~aaxa a    àÿÿÿvk L   (a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      Øÿÿÿvk   €          ActivationType  ğÿÿÿØ»c ¼cP¼chbin €a                       €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ    €ağ‚  ÿÿÿÿ           L       .   Windows.ApplicationModel.Contacts.ContactEmail¶ôèÿÿÿÈa¸€a(aPa    àÿÿÿvk L   Ø€a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ    ‚ağ‚  ÿÿÿÿ           L       .   Windows.ApplicationModel.Contacts.ContactFieldF0Øÿÿÿvk   €          ActivationType  èÿÿÿøa8‚a¨‚aĞ‚a    àÿÿÿvk L   X‚a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      xÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   ¨ƒağ‚  ÿÿÿÿ           L       5   Windows.ApplicationModel.Contacts.ContactFieldFactorykòØÿÿÿvk   €          ActivationType  èÿÿÿ€ƒaÀƒa0„aX„a    àÿÿÿvk L   àƒa      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      pÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   8…ağ‚  ÿÿÿÿ           L       <   Windows.ApplicationModel.Contacts.ContactInstantMessageField¹-‡{Øÿÿÿvk   €          ActivationType  èÿÿÿ…aP…aÀ…aè…a    àÿÿÿvk L   p…a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   ¸†ağ‚  ÿÿÿÿ           L       0   Windows.ApplicationModel.Contacts.ContactJobInfoØÿÿÿvk   €          ActivationType  èÿÿÿ†aĞ†a@‡ah‡a    àÿÿÿvk L   ğ†a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      pÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   Hˆağ‚  ÿÿÿÿ           L       :   Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs±m]’Øÿÿÿvk   €          ActivationType  èÿÿÿ ˆa`ˆaĞˆaøˆa    àÿÿÿvk L   €ˆa      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      xÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   Ğ‰ağ‚  ÿÿÿÿ           L       6   Windows.ApplicationModel.Contacts.ContactLocationFieldäbØÿÿÿvk   €          ActivationType  èÿÿÿ¨‰aè‰aXŠa€Ša    àÿÿÿvk L   Ša      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   P‹ağ‚  ÿÿÿÿ           L       0   Windows.ApplicationModel.Contacts.ContactManagerØÿÿÿvk   €          ActivationType  èÿÿÿ(‹ah‹aØ‹a Œa    àÿÿÿvk L   ˆ‹a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l   Øÿÿÿvk	   €          Threading       Øÿÿÿvk
   €          TrustLevel      €ÿÿÿnk  ºU#ÔŞ¬Õ   Àó\        ÿÿÿÿÿÿÿÿ   ĞŒağ‚  ÿÿÿÿ           L       .   Windows.ApplicationModel.Contacts.ContactPhone  Øÿÿÿvk   €          ActivationType  èÿÿÿ¨ŒaèŒaXa€a    àÿÿÿvk L   a      DllPath °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ C o n t a c t A p i s . d l l