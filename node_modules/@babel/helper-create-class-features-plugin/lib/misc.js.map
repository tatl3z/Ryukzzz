{"version":3,"names":["_core","require","_traverse","findBareSupers","visitors","environmentVisitor","Super","path","node","parentPath","isCallExpression","callee","push","referenceVisitor","TSTypeAnnotation|TypeAnnotation","skip","ReferencedIdentifier","scope","hasOwnBinding","name","rename","handleClassTDZ","state","classBinding","getBinding","classNameTDZError","file","addHelper","throwNode","t","callExpression","stringLiteral","replaceWith","sequenceExpression","classFieldDefinitionEvaluationTDZVisitor","injectInitialization","constructor","nodes","renamer","lastReturnsThis","length","isDerived","superClass","newConstructor","classMethod","identifier","blockStatement","params","restElement","body","template","statement","ast","get","unshiftContainer","bareSupers","traverse","isFirst","bareSuper","map","n","cloneNode","isExpressionStatement","allNodes","toExpression","thisExpression","insertAfter","memoiseComputedKey","keyNode","hint","isUidReference","isIdentifier","hasUid","isMemoiseAssignment","isAssignmentExpression","operator","left","ident","id","kind","assignmentExpression","extractComputedKeys","computedPaths","declarations","computedPath","computedKey","isReferencedIdentifier","computedNode","isConstantExpression","assignment","generateUidBasedOnNode","expressionStatement","key"],"sources":["../src/misc.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { File, NodePath, Scope, Visitor } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\n\nconst findBareSupers = visitors.environmentVisitor<\n  NodePath<t.CallExpression>[]\n>({\n  Super(path) {\n    const { node, parentPath } = path;\n    if (parentPath.isCallExpression({ callee: node })) {\n      this.push(parentPath);\n    }\n  },\n});\n\nconst referenceVisitor: Visitor<{ scope: Scope }> = {\n  \"TSTypeAnnotation|TypeAnnotation\"(\n    path: NodePath<t.TSTypeAnnotation | t.TypeAnnotation>,\n  ) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path: NodePath<t.Identifier>, { scope }) {\n    if (scope.hasOwnBinding(path.node.name)) {\n      scope.rename(path.node.name);\n      path.skip();\n    }\n  },\n};\n\ntype HandleClassTDZState = {\n  classBinding: Scope.Binding;\n  file: File;\n};\n\nfunction handleClassTDZ(\n  path: NodePath<t.Identifier>,\n  state: HandleClassTDZState,\n) {\n  if (\n    state.classBinding &&\n    state.classBinding === path.scope.getBinding(path.node.name)\n  ) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n    const throwNode = t.callExpression(classNameTDZError, [\n      t.stringLiteral(path.node.name),\n    ]);\n\n    path.replaceWith(t.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor: Visitor<HandleClassTDZState> = {\n  ReferencedIdentifier: handleClassTDZ,\n};\n\ninterface RenamerState {\n  scope: Scope;\n}\n\nexport function injectInitialization(\n  path: NodePath<t.Class>,\n  constructor: NodePath<t.ClassMethod> | undefined,\n  nodes: t.ExpressionStatement[],\n  renamer?: (visitor: Visitor<RenamerState>, state: RenamerState) => void,\n  lastReturnsThis?: boolean,\n) {\n  if (!nodes.length) return;\n\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = t.classMethod(\n      \"constructor\",\n      t.identifier(\"constructor\"),\n      [],\n      t.blockStatement([]),\n    );\n\n    if (isDerived) {\n      newConstructor.params = [t.restElement(t.identifier(\"args\"))];\n      newConstructor.body.body.push(template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path\n      .get(\"body\")\n      .unshiftContainer(\"body\", newConstructor) as NodePath<t.ClassMethod>[];\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, { scope: constructor.scope });\n  }\n\n  if (isDerived) {\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        isFirst = false;\n      } else {\n        nodes = nodes.map(n => t.cloneNode(n));\n      }\n      if (!bareSuper.parentPath.isExpressionStatement()) {\n        const allNodes: t.Expression[] = [\n          bareSuper.node,\n          ...nodes.map(n => t.toExpression(n)),\n        ];\n        if (!lastReturnsThis) allNodes.push(t.thisExpression());\n        bareSuper.replaceWith(t.sequenceExpression(allNodes));\n      } else {\n        bareSuper.insertAfter(nodes);\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\ntype ComputedKeyAssignmentExpression = t.AssignmentExpression & {\n  left: t.Identifier;\n};\n\n/**\n * Try to memoise a computed key.\n * It returns undefined when the computed key is an uid reference, otherwise\n * an assignment expression `memoiserId = computed key`\n * @export\n * @param {t.Expression} keyNode Computed key\n * @param {Scope} scope The scope where memoiser id should be registered\n * @param {string} hint The memoiser id hint\n * @returns {(ComputedKeyAssignmentExpression | undefined)}\n */\nexport function memoiseComputedKey(\n  keyNode: t.Expression,\n  scope: Scope,\n  hint: string,\n): ComputedKeyAssignmentExpression | undefined {\n  const isUidReference = t.isIdentifier(keyNode) && scope.hasUid(keyNode.name);\n  if (isUidReference) {\n    return;\n  }\n  const isMemoiseAssignment =\n    t.isAssignmentExpression(keyNode, { operator: \"=\" }) &&\n    t.isIdentifier(keyNode.left) &&\n    scope.hasUid(keyNode.left.name);\n  if (isMemoiseAssignment) {\n    return t.cloneNode(keyNode as ComputedKeyAssignmentExpression);\n  } else {\n    const ident = t.identifier(hint);\n    // Declaring in the same block scope\n    // Ref: https://github.com/babel/babel/pull/10029/files#diff-fbbdd83e7a9c998721c1484529c2ce92\n    scope.push({\n      id: ident,\n      kind: \"let\",\n    });\n    return t.assignmentExpression(\n      \"=\",\n      t.cloneNode(ident),\n      keyNode,\n    ) as ComputedKeyAssignmentExpression;\n  }\n}\n\nexport function extractComputedKeys(\n  path: NodePath<t.Class>,\n  computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[],\n  file: File,\n) {\n  const { scope } = path;\n  const declarations: t.ExpressionStatement[] = [];\n  const state = {\n    classBinding: path.node.id && scope.getBinding(path.node.id.name),\n    file,\n  };\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n    // Make sure computed property names are only evaluated once (upon class definition)\n    // and in the right order in combination with static properties\n    if (!computedKey.isConstantExpression()) {\n      const assignment = memoiseComputedKey(\n        computedKey.node,\n        scope,\n        scope.generateUidBasedOnNode(computedKey.node),\n      );\n      if (assignment) {\n        declarations.push(t.expressionStatement(assignment));\n        computedNode.key = t.cloneNode(assignment.left);\n      }\n    }\n  }\n\n  return declarations;\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAD,OAAA;AAEA,MAAME,cAAc,GAAGC,kBAAQ,CAACC,kBAAkB,CAEhD;EACAC,KAAKA,CAACC,IAAI,EAAE;IACV,MAAM;MAAEC,IAAI;MAAEC;IAAW,CAAC,GAAGF,IAAI;IACjC,IAAIE,UAAU,CAACC,gBAAgB,CAAC;MAAEC,MAAM,EAAEH;IAAK,CAAC,CAAC,EAAE;MACjD,IAAI,CAACI,IAAI,CAACH,UAAU,CAAC;IACvB;EACF;AACF,CAAC,CAAC;AAEF,MAAMI,gBAA2C,GAAG;EAClD,iCAAiCC,CAC/BP,IAAqD,EACrD;IACAA,IAAI,CAACQ,IAAI,CAAC,CAAC;EACb,CAAC;EAEDC,oBAAoBA,CAACT,IAA4B,EAAE;IAAEU;EAAM,CAAC,EAAE;IAC5D,IAAIA,KAAK,CAACC,aAAa,CAACX,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,EAAE;MACvCF,KAAK,CAACG,MAAM,CAACb,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC;MAC5BZ,IAAI,CAACQ,IAAI,CAAC,CAAC;IACb;EACF;AACF,CAAC;AAOD,SAASM,cAAcA,CACrBd,IAA4B,EAC5Be,KAA0B,EAC1B;EACA,IACEA,KAAK,CAACC,YAAY,IAClBD,KAAK,CAACC,YAAY,KAAKhB,IAAI,CAACU,KAAK,CAACO,UAAU,CAACjB,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,EAC5D;IAğÿÿÿ¸ŸüØ üH¡üàÿÿÿvk   €         Count   hbin  ü                       ˆÿÿÿnk  š¯W%ß¬Õ   Ñî       (¢üÿÿÿÿ   ĞŸüÈoŞÿÿÿÿ"           B       &   {e595f735-b42a-494b-afcd-b68666945cd3}  ÀÿÿÿM i c r o s o f t - W i n d o w s - F i r e w a l l         Øÿÿÿvk B    ¡ü      ResourceFileName¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ m p s s v c . d l l     Øÿÿÿvk B   p¡ü      MessageFileName ¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ m p s s v c . d l l     ˜ÿÿÿnk  š¯W%ß¬Õ     ü       £üÿÿÿÿ    ¢üÈoŞÿÿÿÿ       
             ChannelReferences       øÿÿÿàŸüğÿÿÿlh ¸¡ü[ë'†¨ÿÿÿnk  š¯W%ß¬Õ   ¸¡ü        ÿÿÿÿÿÿÿÿ   À¢üÈoŞÿÿÿÿ        
             0       èÿÿÿvk     ¨¢ü       èÿÿÿS y s t e m         ğÿÿÿ¢üĞ¢üğ¢üàÿÿÿvk   €         Id      àÿÿÿvk   €         Flags   ğÿÿÿlh 8¢ü0   ˆÿÿÿnk  š¯W%ß¬Õ   Ñî        ÿÿÿÿÿÿÿÿ   ¤üÈoŞÿÿÿÿ            ^       &   {e5aa2a53-30be-40f5-8d84-ad3f40a404cd}  èÿÿÿvk  ^   °£ü       ˜ÿÿÿM i c r o s o f t - W i n d o w s - T a b l e t P C - P l a t f o r m - I n p u t - W i s p         ğÿÿÿ˜£ü(¤ü˜¤üØÿÿÿvk >   P¤ü      ResourceFileName¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ w i s p . d l l         Øÿÿÿvk >   À¤ü      MessageFileName ¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ w i s p . d l l         ˆÿÿÿnk  š¯W%ß¬Õ   Ñî       x§üÿÿÿÿ   è¥üÈoŞÿÿÿÿ"           H       &   {e5ba83f6-07d0-46b1-8bc7-7e669a1d31dc}  èÿÿÿvk  H   ˜¥ü       °ÿÿÿM i c r o s o f t - W i n d o w s - S e c u r i t y - N e t l o g o n       ğÿÿÿ€¥üø¥üp¦üØÿÿÿvk F    ¦ü      ResourceFileName°ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ n e t l o g o n . d l l         Øÿÿÿvk F   ˜¦ü      MessageFileName °ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ n e t l o g o n . d l l         ˜ÿÿÿnk  š¯W%ß¬Õ   ¥ü       ˜¨üÿÿÿÿ   p§üÈoŞÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿP§üğÿÿÿlh è¦ü[ë'†¨ÿÿÿnk  š¯W%ß¬Õ   è¦ü        ÿÿÿÿÿÿÿÿ   H¨üÈoŞÿÿÿÿ        
   F          0       èÿÿÿvk  F   ø§ü       °ÿÿÿM i c r o s o f t - W i n d o w s - N T L M / O p e r a t i o n a l         ğÿÿÿà§üX¨üx¨üàÿÿÿvk   €         Id      àÿÿÿvk   €         Flags   èÿÿÿlh ˆ§ü0   °¨ü1   ¨ÿÿÿnk  š¯W%ß¬Õ   è¦ü        ÿÿÿÿÿÿÿÿ   ˆ©üÈoŞÿÿÿÿ        
   `          1       èÿÿÿvk  `    ©ü       ˜ÿÿÿM i c r o s o f t - W i n d o w s - S e c u r i t y - N e t l o g o n / O p e r a t i o n a l       ğÿÿÿ©ü˜©ü¸©üàÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ˆÿÿÿnk  š¯W%ß¬Õ   Ñî       X¬üÿÿÿÿ   ¸ªüÈoŞÿÿÿÿ"           R       &   {e5c16d49-2464-4382-bb20-97a4b5465db9}  èÿÿÿvk  J   hªü       °ÿÿÿM i c r o s o f t - W i n d o w s - W i F i N e t w o r k M a n a g e r     ğÿÿÿPªüÈªüH«üØÿÿÿvk R   ğªü      ResourceFileName¨ÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ w i f i n e t w o r k m a n a g e r . d l l     Øÿÿÿvk R   p«ü      MessageFileName ¨ÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ w i f i n e t w o r k m a n a g e r . d l l     ˜ÿÿÿnk  š¯W%ß¬Õ   Ø©ü        ­üÿÿÿÿ   P¬üÈoŞÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿ0¬üğÿÿÿlh È«ü[ë'†¨ÿÿÿnk  š¯W%ß¬Õ   È«ü        ÿÿÿÿÿÿÿÿ   P­üÈoŞÿÿÿÿ        
   p          0       èÿÿÿvk  p   Ø¬ü       ˆÿÿÿM i c r o s o f t - W i n d o w s P h o n e - C o n n e c t i v i t y - W i F i C o n n S v c - C h a n n e l       ğÿÿÿÀ¬ü`­ü€­üàÿÿÿvk   €i         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh h¬ü0   ˆÿÿÿnk  š¯W%ß¬Õ   Ñî       (±üÿÿÿÿ   ¨®üÈoŞÿÿÿÿ"       "   b       &   {e5fc4a0f-7198-492f-9b0f-88fdcbfded48}  èÿÿÿvk  b   @®ü       ˜ÿÿÿM i c r o s o f t - W i n d o w s   N e t w o r k i n g   V P N   P l u g i n  