/**
 * @fileoverview A rule to ensure blank lines within blocks.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 * @deprecated in ESLint v8.53.0
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Require or disallow padding within blocks",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/padded-blocks"
        },

        fixable: "whitespace",

        schema: [
            {
                oneOf: [
                    {
                        enum: ["always", "never"]
                    },
                    {
                        type: "object",
                        properties: {
                            blocks: {
                                enum: ["always", "never"]
                            },
                            switches: {
                                enum: ["always", "never"]
                            },
                            classes: {
                                enum: ["always", "never"]
                            }
                        },
                        additionalProperties: false,
                        minProperties: 1
                    }
                ]
            },
            {
                type: "object",
                properties: {
                    allowSingleLineBlocks: {
                        type: "boolean"
                    }
                },
                additionalProperties: false
            }
        ],

        messages: {
            alwaysPadBlock: "Block must be padded by blank lines.",
            neverPadBlock: "Block must not be padded by blank lines."
        }
    },

    create(context) {
        const options = {};
        const typeOptions = context.options[0] || "always";
        const exceptOptions = context.options[1] || {};

        if (typeof typeOptions === "string") {
            const shouldHavePadding = typeOptions === "always";

            options.blocks = shouldHavePadding;
            options.switches = shouldHavePadding;
            options.classes = shouldHavePadding;
        } else {
            if (Object.prototype.hasOwnProperty.call(typeOptions, "blocks")) {
                options.blocks = typeOptions.blocks === "always";
            }
            if (Object.prototype.hasOwnProperty.call(typeOptions, "switches")) {
                options.switches = typeOptions.switches === "always";
            }
            if (Object.prototype.hasOwnProperty.call(typeOptions, "classes")) {
                options.classes = typeOptions.classes === "always";
            }
        }

        if (Object.prototype.hasOwnProperty.call(exceptOptions, "allowSingleLineBlocks")) {
            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
        }

        const sourceCode = context.sourceCode;

        /**
         * Gets the open brace token from a given node.
         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.
         * @returns {Token} The token of the open brace.
         */
        function getOpenBrace(node) {
            if (node.type === "SwitchStatement") {
                return sourceCode.getTokenBefore(node.cases[0]);
            }

            if (node.type === "StaticBlock") {
                return sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token
            }

            // `BlockStatement` or `ClassBody`
            return sourceCode.getFirstToken(node);
        }

        /**
         * Checks if the given parameter is a comment node
         * @param {ASTNode|Token} node An AST node or token
         * @returns {boolean} True if node is a comment
         */
        function isComment(node) {
            return node.type === "Line" || node.type === "Block";
        }

        /**
         * Checks if there is padding between two tokens
         * @param {Token} first The first token
         * @param {Token} second The second token
         * @returns {boolean} True if there is at least a line between the tokens
         */
        function isPaddingBetweenTokens(first, second) {
            return second.loc.start.line - first.loc.end.line >= 2;
        }


        /**
         * Checks if the given token has a blank line after it.
         * @param {Token} token The token to check.
         * @returns {boolean} Whether or not the token is followed by a blank line.
         */
        function getFirstBlockToken(token) {
            let prev,
                first = token;

            do {
                prev = first;
                first = sourceCode.getTokenAfter(first, { includeComments: true });
            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);

            return first;
        }

        /**
         * Checks if the given token is preceded by a blank line.
         * @param {Token} token The token to check
         * @returns {boolean} Whether or not the token is preceded by a blank line
         */
        function getLastBlockToken(token) {
            let last = token,
                next;

            do {
                next = last;
                last = sourceCode.getTokenBefore(last, { includeComments: true });
            } while (isComment(last) && last.loc.end.line === next.loc.start.line);

            return last;
        }

        /**
         * Checks if a node should be padded, according to the rule config.
         * @param {ASTNode} node The AST node to check.
         * @throws {Error} (Unreachable)
         * @returns {boolean} True if the node should be padded, false otherwise.
         */
        function requirePaddingFor(node) {
            switch (node.type) {
                case "BlockStatement":
                case "StaticBlock":
                    return options.blocks;
                case "SwitchStatement":
                    return options.switches;
                case "ClassBody":
                    return options.classes;

                /* c8 ignore next */
                default:
                    throw new Error("unreachable");
            }
        }

        /**
         * Checks the given BlockStatement node to be padded if the block is not empty.
         * @param {ASTNode} node The AST node of a BlockStatement.
         * @returns {void} undefined.
         */
        function checkPadding(node) {
            const openBrace = getOpenBrace(node),
                firstBlockToken = getFirstBlockToken(openBrace),
                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),
                closeBrace = sourceCode.getLastToken(node),
                lastBlockToken = getLastBlockToken(closeBrace),
                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),
                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);

            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {
                return;
            }

            if (requirePaddingFor(node)) {

                if (!blockHasTopPadding) {
                    context.report({
                        node,
                        loc: {
                            start: tokenBeforeFirst.loc.start,
                            end: firstBlockToken.loc.start
                        },
                        fix(fixer) {
                            return fixer.insertTextAf1 4 B C 8 9 C A 9 D 7 }         ¯ˇˇˇÄ/Ï¯ˇˇˇ®0Ïhbin 0Ï                       ˇˇˇlh  /Ï¸C∂ªàˇˇˇnk  îÅF⁄ﬁ¨’   Œ<        ∞1Ïˇˇˇˇ   ¯/Ï@\  ˇˇˇˇ                   &   {ad6db2cf-0c8d-438b-b25d-9a9a82903b2b}  Ëˇˇˇvk     ¿0Ï       ËˇˇˇI W i n d o w       †ˇˇˇnk  îÅF⁄ﬁ¨’   00Ï        ˇˇˇˇˇˇˇˇ   ®1Ïxï ˇˇˇˇ            N          ProxyStubClsid32Ëˇˇˇvk  N   P1Ï       ®ˇˇˇ{ a 4 6 3 f c b 9 - 6 b 1 c - 4 e 0 d - a 8 0 b - a 2 c a 7 9 9 9 e 2 5 d }         ¯ˇˇˇ81Ïˇˇˇlh ÿ0Ï¸C∂ªàˇˇˇnk  îÅF⁄ﬁ¨’   Œ<        »3Ïˇˇˇˇ   Ë2Ï@\  ˇˇˇˇ            ê       &   {ad72dbfa-3922-5354-a24e-d643d92da230}  Ëˇˇˇvk  ê   P2Ï      hˇˇˇ_ _ F I I t e r a t o r _ 1 _ W i n d o w s _ _ C I n t e r n a l _ _ C S t a t e R e p o s i t o r y _ _ C C u s t o m I n s t a l l W o r k       ¯ˇˇˇ82Ï†ˇˇˇnk  îÅF⁄ﬁ¨’   ¿1Ï        ˇˇˇˇˇˇˇˇ   ¿3Ïxï ˇˇˇˇ            N          ProxyStubClsid32Ëˇˇˇvk  N   h3Ï       ®ˇˇˇ{ c 5 3 e 0 7 e c - 2 5 f 3 - 4 0 9 3 - a a 3 9 - f c 6 7 e a 2 2 e 9 9 d }         ¯ˇˇˇP3Ïˇˇˇlh 2Ï¸C∂ªàˇˇˇnk  îÅF⁄ﬁ¨’   Œ<        ∏5Ïˇˇˇˇ   ÿ4Ï@\  ˇˇˇˇ            j       &   {ad73197d-2cfa-57a6-8993-9fac40feb791}  Ëˇˇˇvk  j   h4Ï     óÒêˇˇˇ_ _ F I R e f e r e n c e A r r a y _ 1 _ W i n d o w s _ _ C F o u n d a t i o n _ _ C T i m e S p a n     ¯ˇˇˇP4Ï†ˇˇˇnk  îÅF⁄ﬁ¨’   ÿ3Ï        ˇˇˇˇˇˇˇˇ   ∞5Ï@\  ˇˇˇˇ            N          ProxyStubClsid32Ëˇˇˇvk  N   X5Ï       ®ˇˇˇ{ 1 1 6 5 9 a 2 3 - 5 8 8 4 - 4 d 1 b - 9 c f 6 - 6 7 d 6 f 4 f 9 0 b 3 6 }         ¯ˇˇˇ@5Ïˇˇˇlh ‡4Ï¸C∂ªàˇˇˇnk  îÅF⁄ﬁ¨’   Œ<        †7Ïˇˇˇˇ   ¿6Ï@\  ˇˇˇˇ            `       &   {AD736464-7886-5872-88E3-395643C94759}  Ëˇˇˇvk  `   X6Ï       òˇˇˇ_ _ F I V e c t o r _ 1 _ W i n d o w s _ _ C S t o r a g e _ _ C I S t o r a g e F o l d e r       ¯ˇˇˇ@6Ï†ˇˇˇnk  îÅF⁄ﬁ¨’   »5Ï        ˇˇˇˇˇˇˇˇ   ò7Ï@\  ˇˇˇˇ            N          ProxyStubClsid32Ëˇˇˇvk  N   @7Ï       ®ˇˇˇ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         ¯ˇˇˇ(7Ïˇˇˇlh »6Ï¸C∂ªàˇˇˇnk  îÅF⁄ﬁ¨’   Œ<        (:Ïˇˇˇˇ   H9Ï@\  ˇˇˇˇ            ˛       &   {AD757BAD-F64A-5527-9B68-A2708FF371AF}  Ëˇˇˇvk  ˛   @8Ï      ¯˛ˇˇ_ _ F I T y p e d E v e n t H a n d l e r _ 2 _ W e b R u n t i m e _ _ C E x t e n s i o n s _ _ C B r o w s i n g E x t e n s i o n _ W e b R u n t i m e _ _ C E x t e n s i o n s _ _ C E x t e n s i o n S c o p e D e s t r o y e d E v e n t A r g s         ¯ˇˇˇ(8Ï†ˇˇˇnk  îÅF⁄ﬁ¨’   ∞7Ï        ˇˇˇˇˇˇˇˇ    :Ï@\  ˇˇˇˇ            N          ProxyStubClsid32Ëˇˇˇvk  N   »9Ï       ®ˇˇˇ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         ¯ˇˇˇ∞9Ïˇˇˇlh P9Ï¸C∂ªàˇˇˇnk  îÅF⁄ﬁ¨’   Œ<        X<Ïˇˇˇˇ   x;Ï@\  ˇˇˇˇ            ¨       &   {AD75D3B5-A9BA-4DF8-A061-909E3122117A}  Ëˇˇˇvk  ¨   »:Ï       Pˇˇˇ_ _ x _ W i n d o w s _ C I n t e r n a l _ C 