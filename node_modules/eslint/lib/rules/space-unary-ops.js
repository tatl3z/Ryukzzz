/**
 * @fileoverview This rule should require or disallow spaces before or after unary operations.
 * @author Marcin Kumorek
 * @deprecated in ESLint v8.53.0
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce consistent spacing before or after unary operators",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/space-unary-ops"
        },

        fixable: "whitespace",

        schema: [
            {
                type: "object",
                properties: {
                    words: {
                        type: "boolean",
                        default: true
                    },
                    nonwords: {
                        type: "boolean",
                        default: false
                    },
                    overrides: {
                        type: "object",
                        additionalProperties: {
                            type: "boolean"
                        }
                    }
                },
                additionalProperties: false
            }
        ],
        messages: {
            unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
            unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
            unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
            wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
            operator: "Unary operator '{{operator}}' must be followed by whitespace.",
            beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
        }
    },

    create(context) {
        const options = context.options[0] || { words: true, nonwords: false };

        const sourceCode = context.sourceCode;

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Check if the node is the first "!" in a "!!" convert to Boolean expression
         * @param {ASTnode} node AST node
         * @returns {boolean} Whether or not the node is first "!" in "!!"
         */
        function isFirstBangInBangBangExpression(node) {
            return node && node.type === "UnaryExpression" && node.argument.operator === "!" &&
                node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
        }

        /**
         * Checks if an override exists for a given operator.
         * @param {string} operator Operator
         * @returns {boolean} Whether or not an override has been provided for the operator
         */
        function overrideExistsForOperator(operator) {
            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
        }

        /**
         * Gets the value that the override was set to for this operator
         * @param {string} operator Operator
         * @returns {boolean} Whether or not an override enforces a space with this operator
         */
        function overrideEnforcesSpaces(operator) {
            return options.overrides[operator];
        }

        /**
         * Verify Unary Word Operator has spaces after the word operator
         * @param {ASTnode} node AST node
         * @param {Object} firstToken first token from the AST node
         * @param {Object} secondToken second token from the AST node
         * @param {string} word The word to be used for reporting
         * @returns {void}
         */
        function verifyWordHasSpaces(node, firstToken, secondToken, word) {
            if (secondToken.range[0] === firstToken.range[1]) {
                context.report({
                    node,
                    messageId: "wordOperator",
                    data: {
                        word
                    },
                    fix(fixer) {
                        return fixer.insertTextAfter(firstToken, " ");
                    }
                });
            }
        }

        /**
         * Verify Unary Word Operator doesn't have spaces after the word operator
         * @param {ASTnode} node AST node
         * @param {Object} firstToken first token from the AST node
         * @param {Object} secondToken second token from the AST node
         * @param {string} word The word to be used for reporting
         * @returns {void}
         */
        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node,
                        messageId: "unexpectedAfterWord",
                        data: {
                            word
                        },
                        fix(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        }
                    });
                }
            }
        }

        /**
         * Check Unary Word Operators for spaces after the word operator
         * @param {ASTnode} node AST node
         * @param {Object} firstToken first token from the AST node
         * @param {Object} secondToken second token from the AST node
         * @param {string} word The word to be used for reporting
         * @returns {void}
         */
        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
            if (overrideExistsForOperator(word)) {
                if (overrideEnforcesSpaces(word)) {
                    verifyWordHasSpaces(node, firstToken, secondToken, word);
                } else {
                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
                }
            } else if (options.words) {
                verifyWordHasSpaces(node, firstToken, secondToken, word);
            } else {
                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
            }
        }

        /**
         * Verifies YieldExpressions satisfy spacing requirements
         * @param {ASTnode} node AST node
         * @returns {void}
         */
        function checkForSpacesAfterYield(node) {
            const tokens = sourceCode.getFirstTokens(node, 3),
                word = "yield";

            if (!node.argument || node.delegate) {
                return;
            }

            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
        }

        /**
         * Verifies AwaitExpressions satisfy spacing requirements
         * @param {ASTNode} node AwaitExpression AST node
         * @returns {void}
         */
        function checkForSpacesAfterAwait(node) {
            const tokens = sourceCode.getFirstTokens(node, 3);

            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
        }

        /**
         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator
         * @param {ASTnode} node AST node
         * @param {Object} firstToken First token in the expression
         * @param {Object} secondToken Second token in the expression
         * @returns {void}
         */
        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
            if (node.prefix) {
                if (isFirstBangInBangBangExpression(node)) {
                    return;
                }
                if (firstToken.range[                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ÈÿÿÿM s R d p C l i e n t S h e l l   C l a s s          ÿÿÿnk  \ÜàŞ¬Õ   XV        ÿÿÿÿÿÿÿÿ   ğVx• ÿÿÿÿ           R          InprocServer32  èÿÿÿvk  R    ¤Y       ¨ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ M s R d p W e b A c c e s s . d l l     Øÿÿÿvk     ¥Y      ThreadingModel  èÿÿÿA p a r t m e n t   Ğÿÿÿlh (¤YCÇÚh¥YuõT(¦YÕ—R¨¦Y×§x§YsQ¨ÿÿÿnk  \ÜàŞ¬Õ   XV        ÿÿÿÿÿÿÿÿ    ¦Yx• ÿÿÿÿ            D          ProgID  èÿÿÿvk  D   Ø¥Y       ¸ÿÿÿM s R d p W e b A c c e s s . M s R d p C l i e n t S h e l l . 1   øÿÿÿÀ¥Y ÿÿÿnk  \ÜàŞ¬Õ   XV        ÿÿÿÿÿÿÿÿ    ¦Yx• ÿÿÿÿ                      Programmable    èÿÿÿvk    €           øÿÿÿˆ¦Y¨ÿÿÿnk  \ÜàŞ¬Õ   XV        ÿÿÿÿÿÿÿÿ   p§Yx• ÿÿÿÿ            N          TypeLib èÿÿÿvk  N   §Y     ( ¨ÿÿÿ{ 3 E A 4 9 5 9 9 - A F 6 7 - 4 1 4 2 - B 3 7 9 - C 5 4 7 8 6 F 1 1 2 B 2 }         øÿÿÿ §Y˜ÿÿÿnk  \ÜàŞ¬Õ   XV        ÿÿÿÿÿÿÿÿ   @¨Yx• ÿÿÿÿ            @          VersionIndependentProgIDèÿÿÿvk  @   ø§Y     T¸ÿÿÿM s R d p W e b A c c e s s . M s R d p C l i e n t S h e l l       øÿÿÿà§Yˆÿÿÿnk  \ÜàŞ¬Õ   àÛ;        (ªYÿÿÿÿ   ©Y@\  ÿÿÿÿ           :       &   {6A68CC80-4337-4dbc-BD27-FBFB1053820B}  èÿÿÿvk  :   Ø¨Y       ÀÿÿÿC S e a r c h L a n g u a g e S u p p o r t   C l a s s     øÿÿÿÀ¨Y ÿÿÿnk  \ÜàŞ¬Õ   H¨Y        ÿÿÿÿÿÿÿÿ   à©Yx• ÿÿÿÿ           B          InProcServer32  èÿÿÿvk  B   ˜©Y       ¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ t q u e r y . d l l     ğÿÿÿ€©Yğ©Y    Øÿÿÿvk 
   ªY    ÂËThreadingModel  ğÿÿÿB o t h     ğÿÿÿlh  ©YCÇÚˆÿÿÿnk  \ÜàŞ¬Õ   àÛ;        ¨«Yÿÿÿÿ   H«Y@\  ÿÿÿÿ0           x       &   {6A6F4B83-45C5-4ca9-BDD9-0D81C12295E4}  èÿÿÿvk  x   ÈªY      €ÿÿÿM i c r o s o f t   R D P   C l i e n t   C o n t r o l   ( r e d i s t r i b u t a b l e )   -   v e r s i o n   4 a       øÿÿÿ°ªY¨ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ    ÿÿÿÿ@\  ÿÿÿÿ                       Control ¸ÿÿÿlh P«YdÁUğ«YCÇÚ ­YÉß ®YuõTÀ®YÕ—R ¯Y×§ğ¯Yât…†x°YsQ ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ   °¬Y@\  ÿÿÿÿ           D          InprocServer32  èÿÿÿvk  D   h¬Y     Ë¸ÿÿÿ% s y s t e m r o o t % \ s y s t e m 3 2 \ m s t s c a x . d l l   ğÿÿÿP¬YÀ¬Y    Øÿÿÿvk    è¬Y    ( ThreadingModel  èÿÿÿA p a r t m e n t    ÿÿÿnk  \ÜàŞ¬Õ   8ªY       ®Yÿÿÿÿ   x­Y@\  ÿÿÿÿ                  
   MiscStatus      èÿÿÿvk    €0         øÿÿÿ`­Y¨ÿÿÿnk  \ÜàŞ¬Õ    ­Y        ÿÿÿÿÿÿÿÿ   ®Y@\  ÿÿÿÿ                      1       èÿÿÿvk     ğ­Y     Ëèÿÿÿ1 3 1 4 7 3         øÿÿÿØ­Yğÿÿÿlh €­Y1   ¨ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ   ¸®Y@\  ÿÿÿÿ                       ProgID  èÿÿÿvk      ®Y       ØÿÿÿM s R D P . M s R D P . 3 . a       øÿÿÿx®Y ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ    ÿÿÿÿ@\  ÿÿÿÿ                       Programmable    ¨ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ   è¯Y@\  ÿÿÿÿ            N          TypeLib èÿÿÿvk  N   ¯Y       ¨ÿÿÿ{ 8 C 1 1 E F A 1 - 9 2 C 3 - 1 1 D 1 - B C 1 E - 0 0 C 0 4 F A 3 1 4 8 9 }         øÿÿÿx¯Y¨ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ   p°Y@\  ÿÿÿÿ                      Version èÿÿÿvk     `°Y     §ğÿÿÿ1 . 0       øÿÿÿH°Y˜ÿÿÿnk  \ÜàŞ¬Õ   8ªY        ÿÿÿÿÿÿÿÿ   ±Y@\  ÿÿÿÿ                      VersionIndependentProgIDèÿÿÿvk     ø°Y      àÿÿÿM s R D P . M s R D P       øÿÿÿà°Yˆÿÿÿnk  õH9º„ŸÚ   àÛ;        P²Yÿÿÿÿ   Ğ±YQ  ÿÿÿÿ      