/**
 * @fileoverview Validates JSDoc comments are syntactically correct
 * @author Nicholas C. Zakas
 * @deprecated in ESLint v5.10.0
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const doctrine = require("doctrine");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Enforce valid JSDoc comments",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/valid-jsdoc"
        },

        schema: [
            {
                type: "object",
                properties: {
                    prefer: {
                        type: "object",
                        additionalProperties: {
                            type: "string"
                        }
                    },
                    preferType: {
                        type: "object",
                        additionalProperties: {
                            type: "string"
                        }
                    },
                    requireReturn: {
                        type: "boolean",
                        default: true
                    },
                    requireParamDescription: {
                        type: "boolean",
                        default: true
                    },
                    requireReturnDescription: {
                        type: "boolean",
                        default: true
                    },
                    matchDescription: {
                        type: "string"
                    },
                    requireReturnType: {
                        type: "boolean",
                        default: true
                    },
                    requireParamType: {
                        type: "boolean",
                        default: true
                    }
                },
                additionalProperties: false
            }
        ],

        fixable: "code",
        messages: {
            unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
            expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
            use: "Use @{{name}} instead.",
            useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
            syntaxError: "JSDoc syntax error.",
            missingBrace: "JSDoc type missing brace.",
            missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
            missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
            missingReturnType: "Missing JSDoc return type.",
            missingReturnDesc: "Missing JSDoc return description.",
            missingReturn: "Missing JSDoc @{{returns}} for function.",
            missingParam: "Missing JSDoc for parameter '{{name}}'.",
            duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
            unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
        },

        deprecated: true,
        replacedBy: []
    },

    create(context) {

        const options = context.options[0] || {},
            prefer = options.prefer || {},
            sourceCode = context.sourceCode,

            // these both default to true, so you have to explicitly make them false
            requireReturn = options.requireReturn !== false,
            requireParamDescription = options.requireParamDescription !== false,
            requireReturnDescription = options.requireReturnDescription !== false,
            requireReturnType = options.requireReturnType !== false,
            requireParamType = options.requireParamType !== false,
            preferType = options.preferType || {},
            checkPreferType = Object.keys(preferType).length !== 0;

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        // Using a stack to store if a function returns or not (handling nested functions)
        const fns = [];

        /**
         * Check if node type is a Class
         * @param {ASTNode} node node to check.
         * @returns {boolean} True is its a class
         * @private
         */
        function isTypeClass(node) {
            return node.type === "ClassExpression" || node.type === "ClassDeclaration";
        }

        /**
         * When parsing a new function, store it in our function stack.
         * @param {ASTNode} node A function node to check.
         * @returns {void}
         * @private
         */
        function startFunction(node) {
            fns.push({
                returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ||
                    isTypeClass(node) || node.async
            });
        }

        /**
         * Indicate that return has been found in the current function.
         * @param {ASTNode} node The return node.
         * @returns {void}
         * @private
         */
        function addReturn(node) {
            const functionState = fns[fns.length - 1];

            if (functionState && node.argument !== null) {
                functionState.returnPresent = true;
            }
        }

        /**
         * Check if return tag type is void or undefined
         * @param {Object} tag JSDoc tag
         * @returns {boolean} True if its of type void or undefined
         * @private
         */
        function isValidReturnType(tag) {
            return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
        }

        /**
         * Check if type should be validated based on some exceptions
         * @param {Object} type JSDoc tag
         * @returns {boolean} True if it can be validated
         * @private
         */
        function canTypeBeValidated(type) {
            return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
                   type !== "NullLiteral" && // {null}
                   type !== "NullableLiteral" && // {?}
                   type !== "FunctionType" && // {function(a)}
                   type !== "AllLiteral"; // {*}
        }

        /**
         * Extract the current and expected type based on the input type object
         * @param {Object} type JSDoc tag
         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and
         * the expected name of the annotation
         * @private
         */
        function getCurrentExpectedTypes(type) {
            let currentType;

            if (type.name) {
                currentType = type;
            } else if (type.expression) {
                currentType = type.expression;
            }

            return {
                currentType,
                expectedTypeName: currentType && preferType[currentType.name]
            };
        }

        /**
         * Gets the location of a JSDoc node in a file
         * @param {Token} jsdocComment The comment that this node is parsed from
         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment
         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag
         */
        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {
            return {
                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),
                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])
            };
        }

        /**
         * Validate type for a given JSDoc node
         * @param {Object} jsdocNode JSDoc node
         * @param {Object} type JSDoc tag
         * @returns {void}
         * @privatğÿÿÿ¸rÈr    ğÿÿÿB o t h     øÿÿÿhrøÿÿÿrhbin r                        ÿÿÿnk  s‡àŞ¬Õ   ør        ÿÿÿÿÿÿÿÿ   Ğrx• ÿÿÿÿ           D          InprocServer32  ¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ b i d i s p l . d l l   Øÿÿÿvk 
   àr      ThreadingModel  àÿÿÿlh  rCÇÚruõT°rsQ¨ÿÿÿnk  s‡àŞ¬Õ   ør        ÿÿÿÿÿÿÿÿ   ğrx• ÿÿÿÿ            ,          ProgID  èÿÿÿvk  ,   €r     ÂËĞÿÿÿb i d i s p l . b i d i r e q u e s t . 1   ˜ÿÿÿnk  s‡àŞ¬Õ   ør        ÿÿÿÿÿÿÿÿ   ørx• ÿÿÿÿ            (          VersionIndependentProgIDèÿÿÿvk  (   0r     TĞÿÿÿb i d i s p l . b i d i r e q u e s t       ˆÿÿÿnk  s‡àŞ¬Õ   àÛ;        hrÿÿÿÿ   @r@\  ÿÿÿÿ           H       &   {b918dbc4-162c-43e5-85bf-19059a776e9e}  èÿÿÿvk  H   ğr       °ÿÿÿR e m o v e   F r o m   F r e q u e n t   P l a c e s   C o m m a n d       øÿÿÿØr ÿÿÿnk  s‡àŞ¬Õ   `r        ÿÿÿÿÿÿÿÿ   rx• ÿÿÿÿ           T          InProcServer32  èÿÿÿvk  T   Àr     —ñ¨ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ w i n d o w s . s t o r a g e . d l l   ğÿÿÿ¨r(r    Øÿÿÿvk    Pr      ThreadingModel  èÿÿÿA p a r t m e n t   ğÿÿÿlh HrCÇÚˆÿÿÿnk  s‡àŞ¬Õ   àÛ;        Xrÿÿÿÿ   @r@\  ÿÿÿÿ           0       &   {b91a4db4-3630-11dc-9eaa-00161718cf63}  èÿÿÿvk  0   r       ÈÿÿÿB u r n   c o m m a n d   i n v o c a t i o n       øÿÿÿğr ÿÿÿnk  s‡àŞ¬Õ   xr        ÿÿÿÿÿÿÿÿ   rx• ÿÿÿÿ           D          InProcServer32  èÿÿÿvk  D   Àr       ¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ s h e l l 3 2 . d l l   ğÿÿÿ¨rr    Øÿÿÿvk    @r    wnThreadingModel  èÿÿÿA p a r t m e n t   ğÿÿÿlh HrCÇÚˆÿÿÿnk  Öh¨Î„ŸÚ   àÛ;        `rÿÿÿÿ   rQ  ÿÿÿÿ0                  &   {B91A578F-C1F1-4815-B14D-73E756272B1C}  èÿÿÿvk     ør       àÿÿÿT e r m   L o o k u p       øÿÿÿàr ÿÿÿnk  ·ó§Î„ŸÚ   hr        ÿÿÿÿÿÿÿÿ   XrQ  ÿÿÿÿ            º          DefaultIcon     èÿÿÿvk  º   ˜r       @ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   S Q L   S e r v e r \ 1 2 0 \ D T S \ P i p e l i n e C o m p o n e n t s \ T x T e r m L o o k u p . d l l , - 2 0 1     øÿÿÿ€r¸ÿÿÿlh  ræùoà¨rû0àxr2.ô¢hrCÇÚ  ruõT° rÕ—R!r×§à!rsQ¨ÿÿÿnk  ì¶¨Î„ŸÚ   hr       hrÿÿÿÿ   (rQ  ÿÿÿÿ
          n         DTSInfo Øÿÿÿvk   €        ô¢ComponentTypeõTàÿÿÿ rHrprrprèr    Øÿÿÿvk   €         CurrentVersion  Øÿÿÿvk
 n  ˜r      UITypeName      ˆşÿÿM i c r o s o f t . D a t a T r a n s f o r m a t i o n S e r v i c e s . D e s i g n . T e r m L o o k u p C o m p o n e n t U I ,   M i c r o s o f t . D a t a t r a n s f o r m a t i o n S e r v i c e s . D a t a F l o w U I ,   V e r s i o n = 1 2 . 0 . 0 . 0 ,   C u l t u r e = n e u t r a l ,   P u b l i c K e y T o k e n = 8 9 8 4 5 d c d 8 0 8 0 c c 9 1         Øÿÿÿvk 0   8r      ResourceFile    ÈÿÿÿD T S P i p e l i n e , 3 4 1 0 1 , 3 4 1 0 2       Øÿÿÿvk L   ˜r      HelpKeyword     °ÿÿÿs q l 1 2 . d t s . d e s i g n e r . t e r m l o o k u p t r a n s . f 1   Øÿÿÿvk
 0   r      SamplesTag      ÈÿÿÿS s i s T e r m L o o k u p T r a n s f o r m       ¨ÿÿÿnk  ì¶¨Î„ŸÚ   ¨r        ÿÿÿÿÿÿÿÿ   `rQ  ÿÿÿÿ                     EN-US   Øÿÿÿvk    Èr      Description     hÿÿÿM i c r o s o f t   S Q L   S e r v e r   D a t a   T r a n s f o r m a t i o n   S e r v i c e s   T e r m   L o o k u p   T r a n s f o r m       øÿÿÿ rğÿÿÿlh HrŒò˜ÿÿÿnk  Öh¨Î„ŸÚ   hr       Xrÿÿÿÿ    ÿÿÿÿQ  ÿÿÿÿL                      Implemented Categories  ˆÿÿÿnk  Öh¨Î„ŸÚ   xr        ÿÿÿÿÿÿÿÿ    ÿÿÿÿQ  ÿÿÿÿ                    &   {5F817056-9558-4FC9-B1DE-87FF04E42375}  ğÿÿÿlh àr¨¤\ ÿÿÿnk  ÅA¨Î„ŸÚ   hr        ÿÿÿÿÿÿÿÿ   ˜rQ  ÿÿÿÿ           °          InprocServer32  èÿÿÿvk  °   àr     THÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   S Q L   S e r v e r \ 1 2 0 \ D T S \ P i p e l i n e C o m p o n e n t s \ T x T e r m L o o k u p . d l l       ğÿÿÿÈr¨r    Øÿÿÿvk 
   Ğr      ThreadingModel  rue;
                            returnsTag = tag;
                            break;

                        case "constructor":
                        case "class":
                            hasConstructor = true;
                            break;

                        case "override":
                        case "inheritdoc":
                            isOverride = true;
                            break;

                        case "abstract":
                        case "virtual":
                            isAbstract = true;
                            break;

                        case "interface":
                            isInterface = true;
                            break;

                        // no default
                    }

                    // check tag preferences
                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {
                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);

                        context.report({
                            node: jsdocNode,
                            messageId: "use",
                            loc: {
                                start: entireTagRange.start,
                                end: {
                                    line: entireTagRange.start.line,
                                    column: entireTagRange.start.column + `@${tag.title}`.length
                                }
                            },
                            data: { name: prefer[tag.title] },
                            fix(fixer) {
                                return fixer.replaceTextRange(
                                    [
                                        jsdocNode.range[0] + tag.range[0] + 3,
                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3
                                    ],
                                    prefer[tag.title]
                                );
                            }
                        });
                    }

                    // validate the types
                    if (checkPreferType && tag.type) {
                        validateType(jsdocNode, tag.type);
                    }
                });

                paramTags.forEach(param => {
                    if (requireParamType && !param.type) {
                        context.report({
                            node: jsdocNode,
                            messageId: "missingParamType",
                            loc: getAbsoluteRange(jsdocNode, param),
                            data: { name: param.name }
                        });
                    }
                    if (!param.description && requireParamDescription) {
                        context.report({
                            node: jsdocNode,
                            messageId: "missingParamDesc",
                            loc: getAbsoluteRange(jsdocNode, param),
                            data: { name: param.name }
                        });
                    }
                    if (paramTagsByName[param.name]) {
                        context.report({
                            node: jsdocNode,
                            messageId: "duplicateParam",
                            loc: getAbsoluteRange(jsdocNode, param),
                            data: { name: param.name }
                        });
                    } else if (!param.name.includes(".")) {
                        paramTagsByName[param.name] = param;
                    }
                });

                if (hasReturns) {
                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
                        context.report({
                            node: jsdocNode,
                            messageId: "unexpectedTag",
                            loc: getAbsoluteRange(jsdocNode, returnsTag),
                            data: {
                       øÿÿÿ¸¯rèÿÿÿvk     ğ¯r     ÂËğÿÿÿ1 . 0       hbin °r                        ÿÿÿnk  ^'àŞ¬Õ   ø«r        ÿÿÿÿÿÿÿÿ    ÿÿÿÿx• ÿÿÿÿ                       Programmable    ¨ÿÿÿnk  ^'àŞ¬Õ   ø«r        ÿÿÿÿÿÿÿÿ   Ğ¯rx• ÿÿÿÿ            N          TypeLib ¨ÿÿÿ{ B 0 E D F 1 5 4 - 9 1 0 A - 1 1 D 2 - B 6 3 2 - 0 0 C 0 4 F 7 9 4 9 8 E }         ¨ÿÿÿnk  ^'àŞ¬Õ   ø«r        ÿÿÿÿÿÿÿÿ   ˆ±rx• ÿÿÿÿ                      Version øÿÿÿØ¯r˜ÿÿÿnk  ^'àŞ¬Õ   ø«r        ÿÿÿÿÿÿÿÿ   @²rx• ÿÿÿÿ            ,          VersionIndependentProgIDèÿÿÿvk  ,   ²r     ÇÚĞÿÿÿM S V i d C t l . M S V i d E n c o d e r   øÿÿÿø±rˆÿÿÿnk  ^'àŞ¬Õ   àÛ;        €¶rÿÿÿÿ   ³r@\  ÿÿÿÿ       H   r       &   {BB64F8A7-BEE7-4E1A-AB8D-7D8273F7FDB6}  èÿÿÿvk  :   Ø²r       ÀÿÿÿS e c u r i t y   a n d   M a i n t e n a n c e   C P L     àÿÿÿÀ²r8³rĞ³rp´rØ´rµrPµràÿÿÿvk r   X³r     InfoTip ˆÿÿÿ@ % S y s t e m R o o t % \ S y s t e m 3 2 \ A c t i o n C e n t e r C P L . d l l , - 2 # i m m u t a b l e 1     Øÿÿÿvk r   ø³r      LocalizedString ˆÿÿÿ@ % S y s t e m R o o t % \ S y s t e m 3 2 \ A c t i o n C e n t e r C P L . d l l , - 1 # i m m u t a b l e 1     Ğÿÿÿvk .    ´r      System.ApplicationName  ÈÿÿÿM i c r o s o f t . A c t i o n C e n t e r         Èÿÿÿvk   €         System.ControlPanel.Category    Àÿÿÿvk$   €         System.ControlPanel.EnableInSafeMode    Èÿÿÿvk    ˆµr      System.Software.TasksFileUrl    èÿÿÿI n t e r n a l      ÿÿÿnk  ^'àŞ¬Õ   H²r        ÿÿÿÿÿÿÿÿ   x¶rx• ÿÿÿÿ            Z          DefaultIcon     èÿÿÿvk  Z   ¶r     €? ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ A c t i o n C e n t e r C P L . d l l , - 1     øÿÿÿ ¶rØÿÿÿlh  µræùoà¨¶rCÇÚ¸·rEğë~¸¹r8¥¯İ ÿÿÿnk  ^'àŞ¬Õ   H²r        ÿÿÿÿÿÿÿÿ   h·rx• ÿÿÿÿ           D          InProcServer32  èÿÿÿvk  D    ·r      ¸ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ s h d o c v w . d l l   ğÿÿÿ·rx·r    Øÿÿÿvk     ·r      ThreadingModel  èÿÿÿA p a r t m e n t   ¨ÿÿÿnk  ^'àŞ¬Õ   H²r       ¨¹rÿÿÿÿ   ˆ¸rx• ÿÿÿÿ       
   N          Instanceàÿÿÿvk N   0¸r      CLSID   ¨ÿÿÿ{ 3 2 8 B 0 3 4 6 - 7 E A F - 4 B B E - A 4 7 9 - 7 C B 8 8 A 0 9 5 F 5 B }         øÿÿÿ¸r ÿÿÿnk  ^'àŞ¬Õ   ¸·r        ÿÿÿÿÿÿÿÿ   p¹rx• ÿÿÿÿ           T          InitPropertyBag Øÿÿÿvk T   ¹r      ResourceDLL     ¨ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ A c t i o n C e n t e r C P L . d l l   ğÿÿÿğ¸r€¹r    Øÿÿÿvk
   €d         ResourceID      ğÿÿÿlh ¸rËV4Ã ÿÿÿnk  ^'àŞ¬Õ   H²r        ÿÿÿÿÿÿÿÿ   @ºrx• ÿÿÿÿ        *             ShellFolder     Øÿÿÿvk
   €        ÂËAttributes      ğÿÿÿºrPºr    Ğÿÿÿvk   €         €WantsParseDisplayName   ˆÿÿÿnk  ^'àŞ¬Õ   àÛ;        p¼rÿÿÿÿ   P»r@\  ÿÿÿÿ           6       &   {BB68A765-9FB7-4D2C-A423-7AE4CD4B006C}  èÿÿÿvk  6   »r     ËÀÿÿÿC W p c T r i d e n t W e b F i l t e r   c l a s s         øÿÿÿøºr ÿÿÿnk  ^'àŞ¬Õ   €ºr        ÿÿÿÿÿÿÿÿ   (¼rx• ÿÿÿÿ           N          InProcServer32  èÿÿÿvk  N   Ğ»r       ¨ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ W p c W e b F i l t e r . d l l         ğÿÿÿ¸»r8¼r    Øÿÿÿvk 
   `¼r     ThreadingModel  ğÿÿÿB o t h     ğÿÿÿlh X»rCÇÚˆÿÿÿnk  ^'àŞ¬Õ   àÛ;         ÿÿÿÿÿÿÿÿ   x½r@\  ÿÿÿÿ        
   d       &   {bb6df56b-cace-11dc-9992-0019b93a3a84}  èÿÿÿvk  d   ½r       ˜ÿÿÿB a c k g r o u n d   I n t e l l i g e n t   T r a n s f e r   C o n t r o l   C l a s s   4 . 0   ğÿÿÿø¼rˆ½r    àÿÿÿvk N   ¨½r      AppID   ¨ÿÿÿ{ 6 9 A D 4 A E E - 5 1 B E - 4 3 9 b - A 9 2 C - 8 6 A E 4 9 0 E 8 B 3 0 }         ˆÿÿÿnk  ^'àŞ¬Õ   àÛ;        Ø¿rÿÿÿÿ   È¾r@\  ÿÿÿÿ           .       &   {BB847B8A-054A-11d2-A894-0000F8084F96}  èÿÿÿvk  .   ¾r       ÈÿÿÿC L S I D _ I P r o p F i n d R e q u e s t         øÿÿÿx¾r ÿÿÿnk  A.ª·ÃŠÚ    ¾r        ÿÿÿÿÿÿÿÿ   ¿rx• ÿÿÿÿ           B          InprocServer32  èÿÿÿvk  B   H¿r     —ñ¸ÿÿÿC : \ W i n d o w s \ S y s W O W 6 4 \ i n e t c o m m . d l l     ğÿÿÿ0¿r ¿r    Øÿÿÿvk 
   È¿r    ( ThreadingModel  ğÿÿÿB o t h     ğÿÿÿlh Ğ¾rCÇÚèÿÿÿvk  D   ˜Àr     €?hbin Àr                       