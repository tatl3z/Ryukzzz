(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('estraverse')) :
  typeof define === 'function' && define.amd ? define(['estraverse'], factory) :
  (global = global || self, global.esquery = factory(global.estraverse));
}(this, (function (estraverse) { 'use strict';

  estraverse = estraverse && Object.prototype.hasOwnProperty.call(estraverse, 'default') ? estraverse['default'] : estraverse;

  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var parser = createCommonjsModule(function (module) {
    /*
     * Generated by PEG.js 0.10.0.
     *
     * http://pegjs.org/
     */
    (function (root, factory) {
      if ( module.exports) {
        module.exports = factory();
      }
    })(commonjsGlobal, function () {

      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      peg$SyntaxError.buildMessage = function (expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function literal(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },
          "class": function _class(expectation) {
            var escapedParts = "",
              i;
            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
            }
            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },
          any: function any(expectation) {
            return "any character";
          },
          end: function end(expectation) {
            return "end of input";
          },
          other: function other(expectation) {
            return expectation.description;
          }
        };
        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch);
          });
        }
        function classEscape(s) {
          return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected) {
          var descriptions = new Array(expected.length),
            i,
            j;
          for (i = 0; i < expected.length; i++) {
            descriptions[i] = describeExpectation(expected[i]);
          }
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found) {
          return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};
        var peg$FAILED = {},
          peg$startRuleFunctions = {
            start: peg$parsestart
          },
          peg$startRuleFunction = peg$parsestart,
          peg$c0 = function peg$c0(ss) {
            return ss.length === 1 ? ss[0] : {
              type: 'matches',
              selectors361F020419785F3D61A16E21øÿÿÿ ğ*øÿÿÿ ñ*øÿÿÿ€ò*hbin ğ*                       Èÿÿÿvk  T   Xğ*    EC7BF47769A92C1F842AC9B5D5E682F509¨ÿÿÿC : \ U s e r s \ I T \ D e s k t o p \ C S G \ S M A R T B I Z \ B L A N K \ 4 \   ÿÿÿnk  Î¢ÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   ğï*˜óâ ÿÿÿÿ        @   ®           64A6391ED9F27B157B03B050D362BED1Èÿÿÿvk  ®   Xñ*      AB2D9BC1155CEE114A4F45FB466AC362HÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ L a n g \ d e - D E \ E C M S d k l a n g _ d e - D E . x m l         ÿÿÿnk  6õ6Ú    @BÓ        ÿÿÿÿÿÿÿÿ   øï*˜óâ ÿÿÿÿ        @   ¶           64A70E2103D6F9D5AB992273FD50A7F2Èÿÿÿvk  ¶   ¸ò*      A03D7DACF6F256548AD329AEFB045C78@ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o \ S h a r e d \ P y t h o n 3 7 _ 6 4 \ L i b \ e n c o d i n g s \ a l i a s e s . p y        ÿÿÿnk  ^~%Ú    @BÓ        ÿÿÿÿÿÿÿÿ   Ğô*˜óâ ÿÿÿÿ        @   ª           64A781E5F0CCA9EBCD71B579B7F6DBA5Èÿÿÿvk  ª    ô*      F8939E560A77186820C6C80F297AF111PÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ I n c l u d e \ 1 0 . 0 . 1 8 3 6 2 . 0 \ u m \ D i r e c t X P a c k e d V e c t o r . h   Úøÿÿÿèó*ÿÿÿnk  €¶9Ú    @BÓ       Èø*ÿÿÿÿ   @ö*˜óâ ÿÿÿÿ@       @   ¼           64A95D3550FCD67499E1BD00BC9F6C24Èÿÿÿvk  ¼   €õ*      B69DC1DBB4EFEAE4384DE65FA55B77C9@ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   S Q L   S e r v e r \ 1 2 0 \ T o o l s \ B i n n \ R e s o u r c e s \ 1 0 3 3 \ s 1 1 c h _ c o n f i g m g r . c h m   øÿÿÿHõ*ÿÿÿnk  €¶9Ú    Øô*        ÿÿÿÿÿÿÿÿ
   àö*˜óâ ÿÿÿÿ            8           B69DC1DBB4EFEAE4384DE65FA55B77C9Øÿÿÿvk	   €        ÁPatchGUIDêÁhêÁĞÿÿÿ¸ö*÷*8÷*˜÷*À÷* ø*(ø*Pø*xø* ø*    Øÿÿÿvk   €        öQMediaCabinet@ú·1àÿÿÿvk 8   X÷*    ÆDFileSƒ°8ÀÿÿÿS L P _ s 1 1 c h _ c o n f i g m g r _ 3 2 _ 1 0 3 3   c±:ÆØÿÿÿvk   €        ışComponentVersionØÿÿÿvk    è÷*    ¡MProductVersionbÛèÿÿÿ1 2 . 0 . 2 0 0 0   Øÿÿÿvk	   €0       @8PatchSizeKÃ§ÈğvØÿÿÿvk   €0       á
PatchAttributesRØÿÿÿvk   €0       ®¸PatchSequence¸~—Øÿÿÿvk   €1       vPSharedComponentØÿÿÿvk
   €0       A'IsFullFileÃNƒMğÿÿÿlh Hö*‘Ÿ·ÿÿÿnk  ´ótTŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   hú*˜óâ ÿÿÿÿ        @   â           64AC88C1A6F90BB4C9C1C263230B8C7BÈÿÿÿvk  â   €ù*    ÇwC6D63D1739C5C7B4FBB3F6C1CEAC172FÿÿÿC : \ P r o g r a m   F i l e s \ T e c h S m i t h \ C a m t a s i a   2 0 2 3 \ L u m a - R e s o u r c e s \ C u r s o r s \ N a t i v e \ W i n d o w s \ W i n d o w s 1 0 \ 1 2 8 x 1 2 8 \ a e r o _ n w s e _ l . p n g   ñ`øÿÿÿHù*ÿÿÿnk  ÁÛ%Ú    @BÓ        ÿÿÿÿÿÿÿÿ   ğû*˜óâ ÿÿÿÿ        @   Ò           64AF1480A2674D1226C06284B365D535Èÿÿÿvk  Ò   û*    r F8939E560A77186820C6C80F297AF111(ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ I n c l u d e \ 1 0 . 0 . 1 8 3 6 2 . 0 \ c p p w i n r t \ w i n r t \ W i n d o w s . D e v i c e s . G e o l o c a t i o n . h   73øÿÿÿàú*ÿÿÿnk  B¹å¿JŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   xı*˜óâ ÿÿÿÿ        @   Ò           64B3F2648799C1456897A2F4E186BBFDÈÿÿÿvk  Ò    ü*      AB2D9BC1155CEE114A4F45FB466AC362(ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ p l u g i n s \ O C R \ F X _ A b b y y _ O C R \ R e s o u r c e s \ C M a p \ E T H K - B 5 - V     øÿÿÿhü*ÿÿÿnk  Š4ÈÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   Øş*˜óâ ÿÿÿÿ        @   ª           64B8A21BCF16B8E528FFB12D6124FB4AÈÿÿÿvk  ª   (ş*      AB2D9BC1155CEE114A4F45FB466AC362PÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ S e q u e n c e s \ j a - J P \ A c t i o n 0 4 . s e q u     øÿÿÿğı*ÿÿÿnk  •ó§8Ú    @BÓ        ÿÿÿÿÿÿÿÿ   ˆÿ*˜óâ ÿÿÿÿ        @   Ö           64B90B47D3EA1FA5CA73F295EBB0E27DÈÿÿÿvk  Ö     +    Ó1E669E91635079D4B8C2436B0DCAB600øÿÿÿPÿ*ÿÿÿnk  wcÆú´’Ú    @BÓ        ÿÿÿÿÿÿÿÿ    +˜óâ ÿÿÿÿ        @   b           64BA649FEF2641DD1DFEFED2B9CFEEBAhbin  +                        ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o \ S h a r e d \ P y t h o n 3 7 _ 6 4 \ L i b \ t e s t \ d e c i m a l t e s t d a t a \ d d C l a s s . d e c T e s t         Èÿÿÿvk  b   8+    r 00000000000000000000000000000000˜ÿÿÿC : \ P r o g r a m   F i l e s \ I B M \ S P S S \ S t a t i s t i c s \ 2 6 \ J R E \ b i n \   C øÿÿÿ +ÿÿÿnk  |[Ú    @BÓ        ÿÿÿÿÿÿÿÿ   Ğ+˜óâ ÿÿÿÿ        @   |           64BB1F0BF0E6754C59E00E73EAE700C8Èÿÿÿvk  |   P+      7761AC0120F813132FC587B0BA254E86€ÿÿÿ2 0 : \ I n t e r f a c e \ { 1 2 D A E 0 B D - D 3 2 3 - 4 6 3 9 - 9 D 5 4 - 0 E E 1 2 5 B E 3 7 E 5 } \ T y p e L i b \   øÿÿÿ+ÿÿÿnk  gû4Ú    @BÓ        ÿÿÿÿÿÿÿÿ   8+˜óâ ÿÿÿÿ        @   °           64BCF2C5E30E0ADADEC0DA443A5F7CF1Èÿÿÿvk  °   €+    tu1BFB89A36A61B675FF8CF7FE624BD0ABHÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ C a t a l o g s \ c a t 5 c 2 f c b 4 6 e 0 3 e a d a 0 e d 0 c a d 4 4 a 3 f 5 c 7 1 f . c a t   ÿÿÿÿøÿÿÿH+ÿÿÿnk  Šœ3Ú    @BÓ        ÿÿÿÿÿÿÿÿ   ˆ+˜óâ ÿÿÿÿ        @   œ           64BD839005E475FAD1988862D544DF40Èÿÿÿvk  œ   è+    1 9926C6E2F5FBD973552FF83D63F79581`ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ b i n \ 1 0 . 0 . 1 8 3 6 2 . 0 \ a r m 6 4 \ x p s a n a l y z e r . e x e   øÿÿÿ°+ÿÿÿnk  •JõAÚ    @BÓ        ÿÿÿÿÿÿÿÿ   è+˜óâ ÿÿÿÿ        @   ¬           64BE672B9CCBDD547AC447FD29F1E8F7Èÿÿÿvk  ¬   8+      DCB13571726C2A64F9E1C79C020E9EA4PÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   S Q L   S e r v e r \ M S S Q L 1 2 . M S S Q L S E R V E R \ M S S Q L \ B i n n \ x e c l r h o s t p k g . m o f   øÿÿÿ +ÿÿÿnk  |D"Ú    @BÓ        ÿÿÿÿÿÿÿÿ   @+˜óâ ÿÿÿÿ        @               64C03C8A2B1E488B1290996FA8EF854EÈÿÿÿvk      ˜+    YZ7CE60E51557270DB54DA89FD61976AEBXÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ A p p   C e r t i f i c a t i o n   K i t \ n e t w t l s t _ w i n 8 1 . v w l   	Önføÿÿÿ`+ÿÿÿnk  è4Ú    @BÓ        ÿÿÿÿÿÿÿÿ   ø	+˜óâ ÿÿÿÿ        @             64C21528105C0234F689BC505155AB65Èÿÿÿvk    ğ+    D7CE60E51557270DB54DA89FD61976AEBøşÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ A p p   C e r t i f i c a t i o n   K i t \ z h - h a n t \ M i c r o s o f t . W i n d o w s . S o f t w a r e L o g o . E x e c u t i o n D r i v e r . r e s o u r c e s . d l l   øÿÿÿ¸+ÿÿÿnk  d‚ÖÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   `+˜óâ ÿÿÿÿ        @   ²           64C4CFDC3CF49A85C83AE3D24FD42DB0Èÿÿÿvk  ²   ¨
+      AB2D9BC1155CEE114A4F45FB466AC362HÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ p l u g i n s \ P D F 3 D \ W i n G D I _ 2 2 . 1 2 _ 1 5 . t x v     øÿÿÿp
+ÿÿÿnk  0Ö‡ÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   è+˜óâ ÿÿÿÿ        @   Î           64C5768FE9D08FF59B3DA9492E631C79Èÿÿÿvk  Î   +      AB2D9BC1155CEE114A4F45FB466AC362(ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ a u i r e s o u r c e s \ F X E x p o r t \ u i \ b m p s e t i n g _ d i a l o g . u i . f x         øÿÿÿØ+ÿÿÿnk  =z1Ú    @BÓ        ÿÿÿÿÿÿÿÿ   8+˜óâ ÿÿÿÿ        @   ˜           64C663E8EA8C42B3400197B19F559999Èÿÿÿvk  ˜   ˜+      98604145BD7BFC9B35D7F8BE7249019F`ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ L i b \ 1 0 . 0 . 1 8 3 6 2 . 0 \ u m \ x 6 4 \ o l e c l i 3 2 . l i b       øÿÿÿ`+ÿÿÿnk  ·Ç6ÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   ˜+˜óâ ÿÿÿÿ        @   ¬           64C77FFF356AFCB50AE499FBD137B1F0Èÿÿÿvk  ¬   è+      AB2D9BC1155CEE114A4F45FB466AC362PÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ L a n g \ p l - P L \ R u l e r l a n g _ p l - P L . x m l   øÿÿÿ°+Èÿÿÿvk  ì   +      AB2D9BC1155CEE114A4F45FBns) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function peg$literalExpectation(text, ignoreCase) {
          return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
          };
        }
        function peg$classExpectation(parts, inverted, ignoreCase) {
          return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
          };
        }
        function peg$anyExpectation() {
          return {
            type: "any"
          };
        }
        function peg$endExpectation() {
          return {
            type: "end"
          };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
            p;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column
            };
            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }
        function peg$buildStructuredError(expected, found, location) {
          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
        }
        function peg$parsestart() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 32 + 0,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseselectors();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s1 = peg$c1();
            }
            s0 = s1;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parse_() {
          var s0, s1;
          var key = peg$currPos * 32 + 1,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = [];
          if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c2;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c3);
            }
          }
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (input.charCodeAt(peg$currPos) === 32) {
              s1 = peg$c2;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              {
                peg$fail(peg$c3);
              }
            }
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseidentifierName() {
          var s0, s1, s2;
          var key = peg$currPos * 32 + 2,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          if (peg$c4.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            {
              peg$fail(peg$c5);
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (peg$c4.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                {
                  peg$fail(peg$c5);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$c6(s1);
          }
          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsebinaryOp() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 32 + 3,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              {
                peg$fail(peg$c8);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                s1 = peg$c9();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 126) {
                s2 = peg$c10;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                {
                  peg$fail(peg$c11);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  s1 = peg$c12();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                  s2 = peg$c13;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  {
                    peg$fail(peg$c14);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();
                  if (s3 !== peg$FAILED) {
                    s1 = peg$c15();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 32) {
                  s1 = peg$c2;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  {
                    peg$fail(peg$c3);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();
                  if (s2 !== peg$FAILED) {
                    s1 = peg$c16();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsehasSelectors() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 32 + 4,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsehasSelector();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                {
                  peg$fail(peg$c18);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsehasSelector();
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c17;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  {
                    peg$fail(peg$c18);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsehasSelector();
                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c19(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseselectors() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 32 + 5,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseselector();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                {
                  peg$fail(peg$c18);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseselector();
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c17;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  {
                    peg$fail(peg$c18);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseselector();
                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c19(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsehasSelector() {
          var s0, s1, s2;
          var key = peg$currPos * 32 + 6,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsebinaryOp();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseselector();
            if (s2 !== peg$FAILED) {
              s1 = peg$c20(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseselector() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 7,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsesequence();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsebinaryOp();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesequence();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parsebinaryOp();
              if (s4 !== peg$FAILED) {
                s5 = peg$parsesequence();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c21(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsesequence() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 32 + 8,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c22;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c23);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseatom();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseatom();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c24(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseatom() {
          var s0;
          var key = peg$currPos * 32 + 9,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos =´    rP    -46EA4715A4073A0EEEBFF12CB2557AB20øÿÿÿÈoPÿÿÿnk  MÂT;Ú    @BÓ        ÿÿÿÿÿÿÿÿ   xpP˜óâ ÿÿÿÿ        @   °           97F43FCDF8E38D554A98A92899ABEA1Aøÿÿÿ ÀWøÿÿÿ°WøÿÿÿØ±WøÿÿÿøµWÈÿÿÿvk  ¸   ĞpP      AB2D9BC1155CEE114A4F45FB466AC362@ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ a u i r e s o u r c e s \ F X E x p o r t \ i m g \ i n f o 2 4 . p n g       ÿÿÿnk  ±AÚ    @BÓ        ÿÿÿÿÿÿÿÿ    pP˜óâ ÿÿÿÿ        @   ´           8F39A46D6617E0035977355554A2DBDDHÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ b i n \ 1 0 . 0 . 1 8 3 6 2 . 0 \ a r m 6 4 \ P r o v i s i o n i n g T e s t H e l p e r . p s d 1   ÿÿÿnk  [ê¬-Ú    @BÓ        ÿÿÿÿÿÿÿÿ    tP˜óâ ÿÿÿÿ        @   ¼           8F3A5BEFB1064613E6D9612E08FF3A54Èÿÿÿvk  ¼   `sP    ÂEABBDA68EA7762AFC77108A22EA83C61@ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ W i n d o w s   K i t s \ 1 0 \ I n c l u d e \ 1 0 . 0 . 1 8 3 6 2 . 0 \ u m \ U s e r C o n s e n t V e r i f i e r I n t e r o p . i d l   øÿÿÿ(sPÿÿÿnk  ª‹ëWTŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   àtP˜óâ ÿÿÿÿ        @              8F3B73FDD5A7FED478D71E767D73E714Èÿÿÿvk     ĞtP    ( 7BF47769A92C1F842AC9B5D5E682F509ğÿÿÿC : \   O f øÿÿÿ˜tPÿÿÿnk  ú#kqSŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   uP˜óâ ÿÿÿÿ        @              8F3B9D5189C6C313E9A47BD820BFC6CDÈÿÿÿvk    €          1D5E3C0FEDA1E123187686FED06E995AøÿÿÿXuPÿÿÿnk  ıÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   wP˜óâ ÿÿÿÿ        @   Î           8F3E1A27F94E91D56B9B962C05043592Èÿÿÿvk  Î   @vP      AB2D9BC1155CEE114A4F45FB466AC362(ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ a u i r e s o u r c e s \ I n k S i g n \ u i \ I n k _ P r e f e r e n c e D l g . u i . f x         øÿÿÿvPÿÿÿnk  %ÂÏ8Ú    @BÓ        ÿÿÿÿÿÿÿÿ   €xP˜óâ ÿÿÿÿ        @   °           8F3E775F4835C615595FECB46CB5D1FDÈÿÿÿvk  °   ÈwP    F 1E669E91635079D4B8C2436B0DCAB600HÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o \ S h a r e d \ P y t h o n 3 7 _ 6 4 \ L i b \ t e s t \ t e s t _ l o n g . p y   { 9 øÿÿÿwPÿÿÿnk  ŞI®+Ú    @BÓ       x|Pÿÿÿÿ   ğyP˜óâ ÿÿÿÿ@       @   º           8F4034CD68D0DE748A7C085C1E342C50Èÿÿÿvk  º   0yP    S ACCDBEE0D5FE6984F9AE7D4D015AE7A8@ÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   S Q L   S e r v e r \ 1 2 0 \ S e t u p   B o o t s t r a p \ S Q L S e r v e r 2 0 1 4 \ x 6 4 \ S h e l l O b j e c t s . d l l   r øÿÿÿøxPÿÿÿnk  ŞI®+Ú    ˆxP        ÿÿÿÿÿÿÿÿ
   zP˜óâ ÿÿÿÿ                        ACCDBEE0D5FE6984F9AE7D4D015AE7A8Øÿÿÿvk	   €        ¸PatchGUIDV¸HW¸ĞÿÿÿhzPÀzPèzP0{Pp{P°{PØ{P |P(|PP|P    Øÿÿÿvk   €          MediaCabinet    àÿÿÿvk     {P    ¸FileĞV¸ØÿÿÿS h e l l O b j e c t s _ 6 4       Øÿÿÿvk    X{P      ComponentVersionèÿÿÿ1 . 0 . 0 . 0       Øÿÿÿvk    ˜{P      ProductVersion  èÿÿÿ1 2 . 0 . 2 0 0 0   Øÿÿÿvk	   €0         PatchSize       Øÿÿÿvk   €0         PatchAttributes Øÿÿÿvk   €0         PatchSequence   Øÿÿÿvk   €1         SharedComponent Øÿÿÿvk
   €0         IsFullFile      ğÿÿÿlh øyPªõ•Dÿÿÿnk   ]TŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   ğ}P˜óâ ÿÿÿÿ        @   º           8F42B149229C5A44881C81127E1F5881Èÿÿÿvk  º   0}P      C6D63D1739C5C7B4FBB3F6C1CEAC172F@ÿÿÿC : \ P r o g r a m   F i l e s \ T e c h S m i t h \ C a m t a s i a   2 0 2 3 \ L u m a - R e s o u r c e s \ C u r s o r s \ N a t i v e \ M a c \ C o l o r e d \ i b e a m . p n g     øÿÿÿø|Pÿÿÿnk  äq¤ÀJŠÚ    @BÓ        ÿÿÿÿÿÿÿÿ   xP˜óâ ÿÿÿÿ        @   Ò           8F42C53AB9305E55ABB6FF260F3F1F83Èÿÿÿvk  Ò    ~P      AB2D9BC1155CEE114A4F45FB466AC362(ÿÿÿC : \ P r o g r a m   F i l e s   ( x 8 6 ) \ F o x i t   S o f t w a r e \ F o x i t   P D F   E d i t o r \ a u i r e s o u r c e s \ P D F A c c e s s i b i l i t y \ i m g \ t a b l e r o w _ 1 6 . p n g     øÿÿÿh~Pÿÿÿnk  í£¯%Ú    @BÓ        ÿÿÿÿÿÿÿÿ   ğP˜óâ ÿÿÿÿ        @   ®           (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c33;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c34);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c35(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseattrOps() {
          var s0, s1, s2;
          var key = peg$currPos * 32 + 13,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c37);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c38;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              {
                peg$fail(peg$c39);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c40(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            if (peg$c41.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              {
                peg$fail(peg$c42);
              }
            }
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseattrEqOps() {
          var s0, s1, s2;
          var key = peg$currPos * 32 + 14,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c22;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c23);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c38;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              {
                peg$fail(peg$c39);
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c40(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseattrName() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 15,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseidentifierName();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c43;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              {
                peg$fail(peg$c44);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseidentifierName();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c43;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                {
                  peg$fail(peg$c44);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseidentifierName();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c45(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseattrValue() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 16,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseattrName();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseattrEqOps();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetype();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseregex();
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c46(s1, s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseattrName();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseattrOps();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsestring();
                    if (s5 === peg$FAILED) {
                      s5 = peg$parsenumber();
                      if (s5 === peg$FAILED) {
                        s5 = peg$parsepath();
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s1 = peg$c46(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseattrName();
              if (s1 !== peg$FAILED) {
                s1 = peg$c47(s1);
              }
              s0 = s1;
            }
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsestring() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 17,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c48;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c49);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c50.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              {
                peg$fail(peg$c51);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c52;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                {
                  peg$fail(peg$c53);
                }
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  {
                    peg$fail(peg$c54);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = peg$c55(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c50.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                {
                  peg$fail(peg$c51);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c52;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  {
                    peg$fail(peg$c53);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c54);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = peg$c55(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c48;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                {
                  peg$fail(peg$c49);
                }
              }
              if (s3 !== peg$FAILED) {
                s1 = peg$c56(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c57;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              {
                peg$fail(peg$c58);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (peg$c59.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                {
                  peg$fail(peg$c60);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c52;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  {
                    peg$fail(peg$c53);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c54);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = peg$c55(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c59.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  {
                    peg$fail(peg$c60);
                  }
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 92) {
                    s4 = peg$c52;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    {
                      peg$fail(peg$c53);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      {
                        peg$fail(peg$c54);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s4 = peg$c55(s4, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c57;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  {
                    peg$fail(peg$c58);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s1 = peg$c56(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsenumber() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 32 + 18,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          if (peg$c61.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            {
              peg$fail(peg$c62);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c61.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              {
                peg$fail(peg$c62);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c43;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              {
                peg$fail(peg$c44);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c61.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              {
                peg$fail(peg$c62);
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c61.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  {
                    peg$fail(peg$c62);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = peg$c63(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsepath() {
          var s0, s1;
          var key = peg$currPos * 32 + 19,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseidentifierName();
          if (s1 !== peg$FAILED) {
            s1 = peg$c64(s1);
          }
          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsetype() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 20,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c65) {
            s1 = peg$c65;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c66);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c67.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                {
                  peg$fail(peg$c68);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c67.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    {
                      peg$fail(peg$c68);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c71(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseflags() {
          var s0, s1;
          var key = peg$currPos * 32 + 21,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = [];
          if (peg$c72.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c73);
            }
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              if (peg$c72.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                {
                  peg$fail(peg$c73);
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseregex() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 32 + 22,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c74;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c75);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c76.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              {
                peg$fail(peg$c77);
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c76.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  {
                    peg$fail(peg$c77);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s3 = peg$c74;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                {
                  peg$fail(peg$c75);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseflags();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  s1 = peg$c78(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsefield() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 32 + 23,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c43;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c44);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifierName();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c43;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                {
                  peg$fail(peg$c44);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifierName();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s5 = peg$c43;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  {
                    peg$fail(peg$c44);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseidentifierName();
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s1 = peg$c79(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsenegation() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 24,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c80) {
            s1 = peg$c80;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c81);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c82(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsematches() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 25,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 9) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c85(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsehas() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 26,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c86) {
            s1 = peg$c86;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c87);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsehasSelectors();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c88(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsefirstChild() {
          var s0, s1;
          var key = peg$currPos * 32 + 27,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 12) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 12;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$c91();
          }
          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parselastChild() {
          var s0, s1;
          var key = peg$currPos * 32 + 28,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 11) === peg$c92) {
            s1 = peg$c92;
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c93);
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = peg$c94();
          }
          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsenthChild() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 29,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 11) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c61.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                {
                  peg$fail(peg$c62);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c61.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    {
                      peg$fail(peg$c62);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c97(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parsenthLastChild() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 32 + 30,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 16) === peg$c98) {
            s1 = peg$c98;
            peg$currPos += 16;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c99);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c61.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                {
                  peg$fail(peg$c62);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c61.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    {
                      peg$fail(peg$c62);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    {
                      peg$fail(peg$c70);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c100(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function peg$parseclass() {
          var s0, s1, s2;
          var key = peg$currPos * 32 + 31,
            cached = peg$resultsCache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c101;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifierName();
            if (s2 !== peg$FAILED) {
              s1 = peg$c103(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }
        function nth(n) {
          return {
            type: 'nth-child',
            index: {
              type: 'literal',
              value: n
            }
          };
        }
        function nthLast(n) {
          return {
            type: 'nth-last-child',
            index: {
              type: 'literal',
              value: n
            }
          };
        }
        function strUnescape(s) {
          return s.replace(/\\(.)/g, function (match, ch) {
            switch (ch) {
              case 'b':
                return '\b';
              case 'f':
                return '\f';
              case 'n':
                return '\n';
              case 'r':
                return '\r';
              case 't':
                return '\t';
              case 'v':
                return '\v';
              default:
                return ch;
            }
          });
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    });
  });

  /**
  * @typedef {"LEFT_SIDE"|"RIGHT_SIDE"} Side
  */

  var LEFT_SIDE = 'LEFT_SIDE';
  var RIGHT_SIDE = 'RIGHT_SIDE';

  /**
   * @external AST
   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html
   */

  /**
   * One of the rules of `grammar.pegjs`
   * @typedef {PlainObject} SelectorAST
   * @see grammar.pegjs
  */

  /**
   * The `sequence` production of `grammar.pegjs`
   * @typedef {PlainObject} SelectorSequenceAST
  */

  /**
   * Get the value of a property which may be multiple levels down
   * in the object.
   * @param {?PlainObject} obj
   * @param {string[]} keys
   * @returns {undefined|boolean|string|number|external:AST}
   */
  function getPath(obj, keys) {
    for (var i = 0; i < keys.length; ++i) {
      if (obj == null) {
        return obj;
      }
      obj = obj[keys[i]];
    }
    return obj;
  }

  /**
   * Determine whether `node` can be reached by following `path`,
   * starting at `ancestor`.
   * @param {?external:AST} node
   * @param {?external:AST} ancestor
   * @param {string[]} path
   * @param {Integer} fromPathIndex
   * @returns {boolean}
   */
  function inPath(node, ancestor, path, fromPathIndex) {
    var current = ancestor;
    for (var i = fromPathIndex; i < path.length; ++i) {
      if (current == null) {
        return false;
      }
      var field = current[path[i]];
      if (Array.isArray(field)) {
        for (var k = 0; k < field.length; ++k) {
          if (inPath(node, field[k], path, i + 1)) {
            return true;
          }
        }
        return false;
      }
      current = field;
    }
    return node === current;
  }

  /**
   * A generated matcher function for a selector.
   * @callback SelectorMatcher
   * @param {?SelectorAST} selector
   * @param {external:AST[]} [ancestry=[]]
   * @param {ESQueryOptions} [options]
   * @returns {void}
  */

  /**
   * A WeakMap for holding cached matcher functions for selectors.
   * @type {WeakMap<SelectorAST, SelectorMatcher>}
  */
  var MATCHER_CACHE = typeof WeakMap === 'function' ? new WeakMap() : null;

  /**
   * Look up a matcher function for `selector` in the cache.
   * If it does not exist, generate it with `generateMatcher` and add it to the cache.
   * In engines without WeakMap, the caching is skipped and matchers are generated with every call.
   * @param {?SelectorAST} selector
   * @returns {SelectorMatcher}
   */
  function getMatcher(selector) {
    if (selector == null) {
      return function () {
        return true;
      };
    }
    if (MATCHER_CACHE != null) {
      var matcher = MATCHER_CACHE.get(selector);
      if (matcher != null) {
        return matcher;
      }
      matcher = generateMatcher(selector);
      MATCHER_CACHE.set(selector, matcher);
      return matcher;
    }
    return generateMatcher(selector);
  }

  /**
   * Create a matcher function for `selector`,
   * @param {?SelectorAST} selector
   * @returns {SelectorMatcher}
   */
  function generateMatcher(selector) {
    switch (selector.type) {
      case 'wildcard':
        return function () {
          return true;
        };
      case 'identifier':
        {
          var value = selector.value.toLowerCase();
          return function (node, ancestry, options) {
            var nodeTypeKey = options && options.nodeTypeKey || 'type';
            return value === node[nodeTypeKey].toLowerCase();
          };
        }
      case 'exactNode':
        return function (node, ancestry) {
          return ancestry.length === 0;
        };
      case 'field':
        {
          var path = selector.name.split('.');
          return function (node, ancestry) {
            var ancestor = ancestry[path.length - 1];
            return inPath(node, ancestor, path, 0);
          };
        }
      case 'matches':
        {
          var matchers = selector.selectors.map(getMatcher);
          return function (node, ancestry, options) {
            for (var i = 0; i < matchers.length; ++i) {
              if (matchers[i](node, ancestry, options)) {
                return true;
              }
            }
            return false;
          };
        }
      case 'compound':
        {
          var _matchers = selector.selectors.map(getMatcher);
          return function (node, ancestry, options) {
            for (var i = 0; i < _matchers.length; ++i) {
              if (!_matchers[i](node, ancestry, options)) {
                return false;
              }
            }
            return true;
          };
        }
      case 'not':
        {
          var _matchers2 = selector.selectors.map(getMatcher);
          return function (node, ancestry, options) {
            for (var i = 0; i < _matchers2.length; ++i) {
              if (_matchers2[i](node, ancestry, options)) {
                return false;
              }
            }
            return true;
          };
        }
      case 'has':
        {
          var _matchers3 = selector.selectors.map(getMatcher);
          return function (node, ancestry, options) {
            var result = false;
            var a = [];
            estraverse.traverse(node, {
              enter: function enter(node, parent) {
                if (parent != null) {
                  a.unshift(parent);
                }
                for (var i = 0; i < _matchers3.length; ++i) {
                  if (_matchers3[i](node, a, options)) {
                    result = true;
                    this["break"]();
                    return;
                  }
                }
              },
              leave: function leave() {
                a.shift();
              },
              keys: options && options.visitorKeys,
              fallback: options && options.fallback || 'iteration'
            });
            return result;
          };
        }
      case 'child':
        {
          var left = getMatcher(selector.left);
          var right = getMatcher(selector.right);
          return function (node, ancestry, options) {
            if (ancestry.length > 0 && right(node, ancestry, options)) {
              return left(ancestry[0], ancestry.slice(1), options);
            }
            return false;
          };
        }
      case 'descendant':
        {
          var _left = getMatcher(selector.left);
          var _right = getMatcher(selector.right);
          return function (node, ancestry, options) {
            if (_right(node, ancestry, options)) {
              for (var i = 0, l = ancestry.length; i < l; ++i) {
                if (_left(ancestry[i], ancestry.slice(i + 1), options)) {
                  return true;
                }
              }
            }
            return false;
          };
        }
      case 'attribute':
        {
          var _path = selector.name.split('.');
          switch (selector.operator) {
            case void 0:
              return function (node) {
                return getPath(node, _path) != null;
              };
            case '=':
              switch (selector.value.type) {
                case 'regexp':
                  return function (node) {
                    var p = getPath(node, _path);
                    return typeof p === 'string' && selector.value.value.test(p);
                  };
                case 'literal':
                  {
                    var literal = "".concat(selector.value.value);
                    return function (node) {
                      return literal === "".concat(getPath(node, _path));
                    };
                  }
                case 'type':
                  return function (node) {
                    return selector.value.value === _typeof(getPath(node, _path));
                  };
              }
              throw new Error("Unknown selector value type: ".concat(selector.value.type));
            case '!=':
              switch (selector.value.type) {
                case 'regexp':
                  return function (node) {
                    return !selector.value.value.test(getPath(node, _path));
                  };
                case 'literal':
                  {
                    var _literal = "".concat(selector.value.value);
                    return function (node) {
                      return _literal !== "".concat(getPath(node, _path));
                    };
                  }
                case 'type':
                  return function (node) {
                    return selector.value.value !== _typeof(getPath(node, _path));
                  };
              }
              throw new Error("Unknown selector value type: ".concat(selector.value.type));
            case '<=':
              return function (node) {
                return getPath(node, _path) <= selector.value.value;
              };
            case '<':
              return function (node) {
                return getPath(node, _path) < selector.value.value;
              };
            case '>':
              return function (node) {
                return getPath(node, _path) > selector.value.value;
              };
            case '>=':
              return function (node) {
                return getPath(node, _path) >= selector.value.value;
              };
          }
          throw new Error("Unknown operator: ".concat(selector.operator));
        }
      case 'sibling':
        {
          var _left2 = getMatcher(selector.left);
          var _right2 = getMatcher(selector.right);
          return function (node, ancestry, options) {
            return _right2(node, ancestry, options) && sibling(node, _left2, ancestry, LEFT_SIDE, options) || selector.left.subject && _left2(node, ancestry, options) && sibling(node, _right2, ancestry, RIGHT_SIDE, options);
          };
        }
      case 'adjacent':
        {
          var _left3 = getMatcher(selector.left);
          var _right3 = getMatcher(selector.right);
          return function (node, ancestry, options) {
            return _right3(node, ancestry, options) && adjacent(node, _left3, ancestry, LEFT_SIDE, options) || selector.right.subject && _left3(node, ancestry, options) && adjacent(node, _right3, ancestry, RIGHT_SIDE, options);
          };
        }
      case 'nth-child':
        {
          var nth = selector.index.value;
          var _right4 = getMatcher(selector.right);
          return function (node, ancestry, options) {
            return _right4(node, ancestry, options) && nthChild(node, ancestry, nth, options);
          };
        }
      case 'nth-last-child':
        {
          var _nth = -selector.index.value;
          var _right5 = getMatcher(selector.right);
          return function (node, ancestry, options) {
            return _right5(node, ancestry, options) && nthChild(node, ancestry, _nth, options);
          };
        }
      case 'class':
        {
          var name = selector.name.toLowerCase();
          return function (node, ancestry, options) {
            if (options && options.matchClass) {
              return options.matchClass(selector.name, node, ancestry);
            }
            if (options && options.nodeTypeKey) return false;
            switch (name) {
              case 'statement':
                if (node.type.slice(-9) === 'Statement') return true;
              // fallthrough: interface Declaration <: Statement { }
              case 'declaration':
                return node.type.slice(-11) === 'Declaration';
              case 'pattern':
                if (node.type.slice(-7) === 'Pattern') return true;
              // fallthrough: interface Expression <: Node, Pattern { }
              case 'expression':
                return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';
              case 'function':
                return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';
            }
            throw new Error("Unknown class name: ".concat(selector.name));
          };
        }
    }
    throw new Error("Unknown selector type: ".concat(selector.type));
  }

  /**
   * @callback TraverseOptionFallback
   * @param {external:AST} node The given node.
   * @returns {string[]} An array of visitor keys for the given node.
   */

  /**
   * @callback ClassMatcher
   * @param {string} className The name of the class to match.
   * @param {external:AST} node The node to match against.
   * @param {Array<external:AST>} ancestry The ancestry of the node.
   * @returns {boolean} True if the node matches the class, false if not.
   */

  /**
   * @typedef {object} ESQueryOptions
   * @property {string} [nodeTypeKey="type"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.
   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.
   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.
   * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.
   */

  /**
   * Given a `node` and its ancestors, determine if `node` is matched
   * by `selector`.
   * @param {?external:AST} node
   * @param {?SelectorAST} selector
   * @param {external:AST[]} [ancestry=[]]
   * @param {ESQueryOptions} [options]
   * @throws {Error} Unknowns (operator, class name, selector type, or
   * selector value type)
   * @returns {boolean}
   */
  function matches(node, selector, ancestry, options) {
    if (!selector) {
      return true;
    }
    if (!node) {
      return false;
    }
    if (!ancestry) {
      ancestry = [];
    }
    return getMatcher(selector)(node, ancestry, options);
  }

  /**
   * Get visitor keys of a given node.
   * @param {external:AST} node The AST node to get keys.
   * @param {ESQueryOptions|undefined} options
   * @returns {string[]} Visitor keys of the node.
   */
  function getVisitorKeys(node, options) {
    var nodeTypeKey = options && options.nodeTypeKey || 'type';
    var nodeType = node[nodeTypeKey];
    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {
      return options.visitorKeys[nodeType];
    }
    if (estraverse.VisitorKeys[nodeType]) {
      return estraverse.VisitorKeys[nodeType];
    }
    if (options && typeof options.fallback === 'function') {
      return options.fallback(node);
    }
    // 'iteration' fallback
    return Object.keys(node).filter(function (key) {
      return key !== nodeTypeKey;
    });
  }

  /**
   * Check whether the given value is an ASTNode or not.
   * @param {any} node The value to check.
   * @param {ESQueryOptions|undefined} options The options to use.
   * @returns {boolean} `true` if the value is an ASTNode.
   */
  function isNode(node, options) {
    var nodeTypeKey = options && options.nodeTypeKey || 'type';
    return node !== null && _typeof(node) === 'object' && typeof node[nodeTypeKey] === 'string';
  }

  /**
   * Determines if the given node has a sibling that matches the
   * given selector matcher.
   * @param {external:AST} node
   * @param {SelectorMatcher} matcher
   * @param {external:AST[]} ancestry
   * @param {Side} side
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */
  function sibling(node, matcher, ancestry, side, options) {
    var _ancestry = _slicedToArray(ancestry, 1),
      parent = _ancestry[0];
    if (!parent) {
      return false;
    }
    var keys = getVisitorKeys(parent, options);
    for (var i = 0; i < keys.length; ++i) {
      var listProp = parent[keys[i]];
      if (Array.isArray(listProp)) {
        var startIndex = listProp.indexOf(node);
        if (startIndex < 0) {
          continue;
        }
        var lowerBound = void 0,
          upperBound = void 0;
        if (side === LEFT_SIDE) {
          lowerBound = 0;
          upperBound = startIndex;
        } else {
          lowerBound = startIndex + 1;
          upperBound = listProp.length;
        }
        for (var k = lowerBound; k < upperBound; ++k) {
          if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  /**
   * Determines if the given node has an adjacent sibling that matches
   * the given selector matcher.
   * @param {external:AST} node
   * @param {SelectorMatcher} matcher
   * @param {external:AST[]} ancestry
   * @param {Side} side
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */
  function adjacent(node, matcher, ancestry, side, options) {
    var _ancestry2 = _slicedToArray(ancestry, 1),
      parent = _ancestry2[0];
    if (!parent) {
      return false;
    }
    var keys = getVisitorKeys(parent, options);
    for (var i = 0; i < keys.length; ++i) {
      var listProp = parent[keys[i]];
      if (Array.isArray(listProp)) {
        var idx = listProp.indexOf(node);
        if (idx < 0) {
          continue;
        }
        if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {
          return true;
        }
        if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) && matcher(listProp[idx + 1], ancestry, options)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Determines if the given node is the `nth` child.
   * If `nth` is negative then the position is counted
   * from the end of the list of children.
   * @param {external:AST} node
   * @param {external:AST[]} ancestry
   * @param {Integer} nth
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */
  function nthChild(node, ancestry, nth, options) {
    if (nth === 0) {
      return false;
    }
    var _ancestry3 = _slicedToArray(ancestry, 1),
      parent = _ancestry3[0];
    if (!parent) {
      return false;
    }
    var keys = getVisitorKeys(parent, options);
    for (var i = 0; i < keys.length; ++i) {
      var listProp = parent[keys[i]];
      if (Array.isArray(listProp)) {
        var idx = nth < 0 ? listProp.length + nth : nth - 1;
        if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * For each selector node marked as a subject, find the portion of the
   * selector that the subject must match.
   * @param {SelectorAST} selector
   * @param {SelectorAST} [ancestor] Defaults to `selector`
   * @returns {SelectorAST[]}
   */
  function subjects(selector, ancestor) {
    if (selector == null || _typeof(selector) != 'object') {
      return [];
    }
    if (ancestor == null) {
      ancestor = selector;
    }
    var results = selector.subject ? [ancestor] : [];
    var keys = Object.keys(selector);
    for (var i = 0; i < keys.length; ++i) {
      var p = keys[i];
      var sel = selector[p];
      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));
    }
    return results;
  }

  /**
  * @callback TraverseVisitor
  * @param {?external:AST} node
  * @param {?external:AST} parent
  * @param {external:AST[]} ancestry
  */

  /**
   * From a JS AST and a selector AST, collect all JS AST nodes that
   * match the selector.
   * @param {external:AST} ast
   * @param {?SelectorAST} selector
   * @param {TraverseVisitor} visitor
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */
  function traverse(ast, selector, visitor, options) {
    if (!selector) {
      return;
    }
    var ancestry = [];
    var matcher = getMatcher(selector);
    var altSubjects = subjects(selector).map(getMatcher);
    estraverse.traverse(ast, {
      enter: function enter(node, parent) {
        if (parent != null) {
          ancestry.unshift(parent);
        }
        if (matcher(node, ancestry, options)) {
          if (altSubjects.length) {
            for (var i = 0, l = altSubjects.length; i < l; ++i) {
              if (altSubjects[i](node, ancestry, options)) {
                visitor(node, parent, ancestry);
              }
              for (var k = 0, m = ancestry.length; k < m; ++k) {
                var succeedingAncestry = ancestry.slice(k + 1);
                if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {
                  visitor(ancestry[k], parent, succeedingAncestry);
                }
              }
            }
          } else {
            visitor(node, parent, ancestry);
          }
        }
      },
      leave: function leave() {
        ancestry.shift();
      },
      keys: options && options.visitorKeys,
      fallback: options && options.fallback || 'iteration'
    });
  }

  /**
   * From a JS AST and a selector AST, collect all JS AST nodes that
   * match the selector.
   * @param {external:AST} ast
   * @param {?SelectorAST} selector
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */
  function match(ast, selector, options) {
    var results = [];
    traverse(ast, selector, function (node) {
      results.push(node);
    }, options);
    return results;
  }

  /**
   * Parse a selector string and return its AST.
   * @param {string} selector
   * @returns {SelectorAST}
   */
  function parse(selector) {
    return parser.parse(selector);
  }

  /**
   * Query the code AST using the selector string.
   * @param {external:AST} ast
   * @param {string} selector
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */
  function query(ast, selector, options) {
    return match(ast, parse(selector), options);
  }
  query.parse = parse;
  query.match = match;
  query.traverse = traverse;
  query.matches = matches;
  query.query = query;

  return query;

})));
