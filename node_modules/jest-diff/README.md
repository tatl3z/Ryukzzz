# jest-diff

Display differences clearly so people can review changes confidently.

The `diff` named export serializes JavaScript **values**, compares them line-by-line, and returns a string which includes comparison lines.

Two named exports compare **strings** character-by-character:

- `diffStringsUnified` returns a string.
- `diffStringsRaw` returns an array of `Diff` objects.

Three named exports compare **arrays of strings** line-by-line:

- `diffLinesUnified` and `diffLinesUnified2` return a string.
- `diffLinesRaw` returns an array of `Diff` objects.

## Installation

To add this package as a dependency of a project, run either of the following commands:

- `npm install jest-diff`
- `yarn add jest-diff`

## Usage of `diff()`

Given JavaScript **values**, `diff(a, b, options?)` does the following:

1. **serialize** the values as strings using the `pretty-format` package
2. **compare** the strings line-by-line using the `diff-sequences` package
3. **format** the changed or common lines using the `chalk` package

To use this function, write either of the following:

- `const {diff} = require('jest-diff');` in CommonJS modules
- `import {diff} from 'jest-diff';` in ECMAScript modules

### Example of `diff()`

```js
const a = ['delete', 'common', 'changed from'];
const b = ['common', 'changed to', 'insert'];

const difference = diff(a, b);
```

The returned **string** consists of:

- annotation lines: describe the two change indicators with labels, and a blank line
- comparison lines: similar to â€œunifiedâ€ view on GitHub, but `Expected` lines are green, `Received` lines are red, and common lines are dim (by default, see Options)

```diff
- Expected
+ Received

  Array [
-   "delete",
    "common",
-   "changed from",
+   "changed to",
+   "insert",
  ]
```

### Edge cases of `diff()`

Here are edge cases for the return value:

- `' Comparing two different types of values. â€¦'` if the arguments have **different types** according to the `jest-get-type` package (instances of different classes have the same `'object'` type)
- `'Compared values have no visual difference.'` if the arguments have either **referential identity** according to `Object.is` method or **same serialization** according to the `pretty-format` package
- `null` if either argument is a so-called **asymmetric matcher** in Jasmine or Jest

## Usage of diffStringsUnified

Given **strings**, `diffStringsUnified(a, b, options?)` does the following:

1. **compare** the strings character-by-character using the `diff-sequences` package
2. **clean up** small (often coincidental) common substrings, also known as chaff
3. **format** the changed or common lines using the `chalk` package

Although the function is mainly for **multiline** strings, it compares any strings.

Write either of the following:

- `const {diffStringsUnified} = require('jest-diff');` in CommonJS modules
- `import {diffStringsUnified} from 'jest-diff';` in ECMAScript modules

### Example of diffStringsUnified

```js
const a = 'common\nchanged from';
const b = 'common\nchanged to';

const difference = diffStringsUnified(a, b);
```

The returned **string** consists of:

- annotation lines: describe the two change indicators with labels, and a blank line
- comparison lines: similar to â€œunifiedâ€ view on GitHub, and **changed substrings** have **inverse** foreground and background colors (that is, `from` has white-on-green and `to` has white-on-red, which the following example does not show)

```diff
- Expected
+ Received

  common
- changed from
+ changed to
```

### Performance of diffStringsUnified

To get the benefit of **changed substrings** within the comparison lines, a character-by-character comparison has a higher computational cost (in time and space) than a line-by-line comparison.

If the input strings can have **arbitrary length**, we recommend that the calling code set a limit, beyond which splits the strings, and then calls `diffLinesUnified` instead. For example, Jest falls back to line-by-line comparison if either string has length greater than 20K characters.

## Usage of diffLinesUnified

Given **arrays of strings**, `diffLinesUnified(aLines, bLines, options?)` does the following:

1. **compare** the arrays line-by-line using the `diff-sequences` package
2. **format** the changed or common lines using the `chalk` package

You might call this function when strings have been split into lines and you do not need to see changed substrings within lines.

### Example of diffLinesUnified

```js
const aLines = ['delete', 'common', 'changed from'];
const bLines = ['common', 'changed to', 'insert'];

const difference = diffLinesUnified(aLines, bLines);
```

```diff
- Expected
+ Received

- delete
  common
- changed from
+ changed to
+ insert
```

### Edge cases of diffLinesUnified or diffStringsUnified

Here are edge cases for arguments and return values:

- both `a` and `b` are empty strings: no comparison lines
- only `a` is empty string: all comparison lines have `bColor` and `bIndicator` (see Options)
- only `b` is empty string: all comparison lines have `aColor` and `aIndicator` (see Options)
- `a` and `b` are equal non-empty strings: all comparison lines have `commonColor` and `commonIndicator` (see Options)

## Usage of diffLinesUnified2

Given two **pairs** of arrays of strings, `diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options?)` does the following:

1. **compare** the pair of `Compare` arrays line-by-line using the `diff-sequences` package
2. **format** the corresponding lines in the pair of `Display` arrays using the `chalk` package

Jest calls this function to consider lines as common instead of changed if the only difference is indentation.

You might call this function for case insensitive or Unicode equivalence comparison of lines.

### Example of diffLinesUnified2

```js
import {format} from 'pretty-format';

const a = {
  text: 'Ignore indentation in serialized object',
  time: '2019-09-19T12:34:56.000Z',
  type: 'CREATE_ITEM',
};
const b = {
  payload: {
    text: 'Ignore indentation in serialized object',
    time: '2019-09-19T12:34:56.000Z',
  },
  type: 'CREATE_ITEM',
};

const difference = diffLinesUnified2(
  // serialize with indentation to display lines
  format(a).split('\n'),
  format(b).split('\n'),
  // serialize without indentation to compare lines
  format(a, {indent: 0}).split('\n'),
  format(b, {indent: 0}).split('\n'),
);
```

The `text` and `time` properties are common, because their only difference is indentation:

```diff
- Expected
+ Received

  Object {
+   payload: Object {
      text: 'Ignore indentation in serialized object',
      time: '2019-09-19T12:34:56.000Z',
+   },
    type: 'CREATE_ITEM',
  }
```

The preceding example illustrates why (at least for indentation) it seems more intuitive that the function returns the common line from the `bLinesDisplay` array instead of from the `aLinesDisplay` array.

## Usage of diffStringsRaw

Given **strings** and a boolean option, `diffStringsRaw(a, b, cleanup)` does the following:

1. **compare** the strings character-by-character using the `diff-sequences` package
2. optionally **clean up** small (often coincidental) common substrings, also known as chaff

Because `diffStringsRaw` returns the difference as **data** instead of a string, you can format it as your application requires (for example, enclosed in HTML markup for browser instead of escape sequences for console).

The returned **array** describes substrings as instances of the `Diff` class, which calling code can access like array tuples:

The value at index `0` is one of the following:

| value | named export  | description           |
| ----: | :------------ | :-------------------- |
|   `0` | `DIFF_EQUAL`  | in `a` and in `b`     |
|  `-1` | `DIFF_DELETE` | in `a` but not in `b` |
|   `1` | `DIFF_INSERT` | in `b` but not in `a` |

The value at index `1` is a substring of `a` or `b` or both.

### Example of diffStringsRaw with cleanup

```js
const diffs = diffStringsRaw('changed from', 'changed to', true);
```

| `i` | `diffs[i][0]` | `diffs[i][1]` |
| --: | ------------: | :------------ |
| `0` |           `0` | `'changed '`  |
| `1` |          `-1` | `'from'`      |
| `2` |           `1` | `'to'`        |

### Example of diffStringsRaw without cleanup

```js
const diffs = diffStringsRaw('changed from', 'changed to', false);
```

| `i` | `diffs[i][0]` | `diffs[i][1]` |
| --: | ------------: | :------------ |
| `0` |           `0` | `'changed '`  |
| `1` |          `-1` | `'fr'`        |
| `2` |           `1` | `'t'`         |
| `3` |           `0` | `'o'`         |
| `4` |          `-1` | `'m'`         |

### Advanced import for diffStringsRaw

Here are all the named imports that you might need for the `diffStringsRaw` function:

- `const {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff, diffStringsRaw} = require('jest-diff');` in CommonJS modules
- `import {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff, diffStringsRaw} from 'jest-diff';` in ECMAScript modules

To write a **formatting** function, you might need the named constants (and `Diff` in TypeScript annotations).

If you write an application-specific **cleanup** algorithm, then you might need to call the `Diff` constructor:

```js
const diffCommon = new Diff(DIFF_EQUAL, 'changed ');
const diffDelete = new Diff(DIFF_DELETE, 'from');
const diffInsert = new Diff(DIFF_INSERT, 'to');
```

## Usage of diffLinesRaw

Given **arrays of strings**, `diffLinesRaw(aLines, bLines)` does the following:

- **compare** the arrays line-by-line using the `diff-sequences` package

Because `diffLinesRaw` returns the difference as **data** instead of a string, you can format it as your application requires.

### Example of diffLinesRaw

```js
const aLines = ['delete', 'common', 'changed from'];
const bLines = ['common', 'changed to', 'insert'];

const diffs = diffLinesRaw(aLines, bLines);
```

| `i` | `diffs[i][0]` | `diffs[i][1]`    |
| --: | ------------: | :--------------- |
| `0` |          `-1` | `'delete'`       |
| `1` |           `0` | `'common'`       |
| `2` |          `-1` | `'changed from'` |
| `3` |           `1` | `'changed to'`   |
| `4` |           `1` | `'insert'`       |

### Edge case of diffLinesRaw

If you call `string.split('\n')` for an empty string:

- the result is `['']` an array which contains an empty string
- instead of `[]` an empty array

Depending of your application, you might call `diffLinesRaw` with either array.

### Example of split method

```js
import {diffLinesRaw} from 'jest-diff';

const a = 'non-empty string';
const b = '';

const diffs = diffLinesRaw(a.split('\n'), b.split('\n'));
```

| `i` | `diffs[i][0]` | `diffs[i][1]`        |
| --: | ------------: | :------------------- |
| `0` |          `-1` | `'non-empty string'` |
| `1` |           `1` | `''`                 |

Which you might format as follows:

```diff
- Expected  - 1
+ Received  + 1

- non-empty string
+
```

### Example of splitLines0 function

For edge case behavior like the `diffLinesUnified` function, you might define a `splitLines0` function, which given an empty string, returns `[]` an empty array:

```js
export const splitLines0 = string =>
  string.length === 0 ? [] : string.split('\n');
```

```js
import {diffLinesRaw} from 'jest-diff';

const a = '';
const b = 'line 1\nline 2\nline 3';

const diffs = diffLinesRaw(a.split('\n'), b.split('\n'));
```

| `i` | `diffs[i][0]` | `diffs[i][1]` |
| --: | ------------: | :------------ |
| `0` |           `1` | `'line 1'`    |
| `1` |           `1` | `'line 2'`    |
| `2` |           `1` | `'line 3'`    |

Which you might format as follows:

```diff
- Expected  - 0
+ Received  + 3

+ line 1
+ line 2
+ line 3
```

In contrast to the `diffLinesRaw` function, the `diffLinesUnified` and `diffLinesUnified2` functions **automatically** convert array arguments computed by string `split` method, so callers do **not** need a `splitLine0` function.

## Options

The default options are for the report when an assertion fails from the `expect` package used by Jest.

For other applications, you can provide an options object as a third argument:

- `diff(a, b, options)`
- `diffStringsUnified(a, b, options)`
- `diffLinesUnified(aLines, bLines, options)`
- `diffL; S Y ) ( A ; ; F R ; ; ; I U )         àÿÿÿvk R    †      Author  ¨ÿÿÿ$ ( @ % S y s t e m R o o t % \ s y s t e m 3 2 \ p n p u i . d l l , - 6 0 0 )     Øÿÿÿvk R   ˜ †      Description     ¨ÿÿÿ$ ( @ % S y s t e m R o o t % \ s y s t e m 3 2 \ p n p u i . d l l , - 6 0 2 )     àÿÿÿvk €   !†      URI     xÿÿÿ\ M i c r o s o f t \ W i n d o w s \ P l u g   a n d   P l a y \ D e v i c e   I n s t a l l   R e b o o t   R e q u i r e d       àÿÿÿvk   ¸!†      Triggershşÿÿ        ÕaÈÕa         ÕaÈÕaÿÿÿÿÿÿÿÿÀHHHHàŞíHHHH   HHHHU s e r s   HHHH    HHHH HHHHHHH HHHHHHH   HHHH   HHHH        HHHH    HHHH,   HHHH    ÿÿÿÿ€ô ÿÿÿÿ                           HHHHff       ÕaÈÕa         ÕaÈÕaÿÿÿÿÿÿÿÿ    ÿÿÿÿ             ÁÙ0}\{E436EB84-52    HHHHu¼£= –        ªª       ÕaÈÕa         ÕaÈÕaÿÿÿÿÿÿÿÿ    ÿÿÿÿ             ÁÙ                 HHHHHHHHHHH    àÿÿÿvk *   p#†      Actions Ğÿÿÿ 
   U s e r s ww    ‚GyHj¹G½R_•Ôœ      Øÿÿÿvk $   È#†      DynamicInfo     Øÿÿÿ   –ä¸FŠÚ7F¡«0Û        7üt£«0Ûˆÿÿÿnk  ó	FŠÚ   ˜¯„        ÿÿÿÿÿÿÿÿ
   à$† 0„ÿÿÿÿ        $   æ       &   {4EBE9A38-6BE4-429E-8588-B460327DB327}  àÿÿÿvk R   ˆ$†      Path    ¨ÿÿÿ\ M i c r o s o f t \ W i n d o w s \ A p p I D \ P o l i c y C o n v e r t e r     Ğÿÿÿh$†%†X%†x&†ø&†x'† (†x(†@)†è)†    àÿÿÿvk     0%†      Hash    Øÿÿÿã”‚)Ñe?»W²Èi'QÜ<Í$dö¾²<Êàxš    Ğÿÿÿvk æ   ˆ%†      SecurityDescriptor      ÿÿÿD : ( A ; ; F A ; ; ; B A ) ( A ; ; F A ; ; ; S Y ) ( A ; C I ; F A ; ; ; L S ) ( A ; C I ; F A ; ; ; S - 1 - 5 - 8 0 - 2 0 7 8 4 9 5 7 4 4 - 2 4 1 6 9 0 3 4 6 9 - 4 0 7 2 1 8 4 6 8 5 - 3 9 4 3 8 5 8 3 0 5 - 9 7 6 9 8 7 4 1 7 )         àÿÿÿvk X   ˜&†      Source   ÿÿÿ$ ( @ % s y s t e m r o o t % \ s y s t e m 3 2 \ a p p i d s v c . d l l , - 3 0 0 )       àÿÿÿvk X   '†      Author   ÿÿÿ$ ( @ % s y s t e m r o o t % \ s y s t e m 3 2 \ a p p i d s v c . d l l , - 3 0 1 )       Øÿÿÿvk X    '†      Description      ÿÿÿ$ ( @ % s y s t e m r o o t % \ s y s t e m 3 2 \ a p p i d s v c . d l l , - 3 0 2 )       àÿÿÿvk P    (†      URI     ¨ÿÿÿM i c r o s o f t \ W i n d o w s \ A p p I D \ P o l i c y C o n v e r t e r       àÿÿÿvk     ˜(†      TriggersXÿÿÿ        À­”ÃÙÿÿÿÿÿÿÿÿ À­”ÃÙ        HBHHHH$ÜìHHHH   HHHHL o c a l S y s t e m       HHHH HHHHHHH HHHHHHH   HHHH   HHHH        HHHH    HHHH    HHHH    àÿÿÿvk „   `)†    tActions xÿÿÿ    L o c a l S y s t e m ff    T   % w i n d i r % \ s y s t e m 3 2 \ a p p i d p o l i c y c o n v e r t e r . e x e           Øÿÿÿvk $   *†      DynamicInfoH    Øÿÿÿ   ó	FŠÚ                        ˆÿÿÿnk  'q¡Ú   ˜¯„        ÿÿÿÿÿÿÿÿ   @+†¨,„ÿÿÿÿ        $   0      &   {4ED9FD69-E67C-4139-A7EF-243E9E810B7C}üéàÿÿÿvk h   Ğ*†    8 Pathw e ÿÿÿ\ M i c r o s o f t \ W i n d o w s \ U p d a t e O r c h e s t r a t o r \ S c h e d u l e   S c a n   `¹AØÿÿÿ°*†h+†°+†Ğ+†`,†ğ,†H.†ğ.†    àÿÿÿvk     ˆ+†    s Hashx m Øÿÿÿ¶ö9ë§Öï3qÖWÄõï{m×&ÙÍ;>Ô¾Êùá·ùñ    àÿÿÿvk   €        Schema  Ğÿÿÿvk X    ,†    0_SecurityDescriptor8wekyb ÿÿÿD : P ( A ; ; F A ; ; ; S Y ) ( A ; ; F R F X ; ; ; L S ) ( A ; ; F R F X ; ; ; B A )   |   àÿÿÿvk h   €,†    ËURI  dÿÿÿ\ M i c r o s o f t \ W i n d o w s \ U p d a t e O r c h e s t r a t o r \ S c h e d u l e   S c a n   1h2tàÿÿÿvk 0  -†    E TriggersÈşÿÿ             s…É¡Ô     ÿÿÿÿÿÿÿÿÀ!BBHHHHcj[5HHHH   HHHHA u t h o r   HH    HHHH HHHHHHH HHHHHHH   HHHH   HHHH        HHHH    HHHH,   HHHHX    €ô ÿÿÿÿ                           HHHHİİ            s…É¡Ô                                `5     ÿÿÿÿ             jô   XM  ˜'      HHHH    àÿÿÿvk ~   h.†      Actions xÿÿÿ    A u t h o r ff    F   % s y s t e m r o o t % \ s y s t e m 3 2 \ u s o c l i e n t . e x e    S t a r t S c a n       0 _ x Øÿÿÿvk $   /†    d DynamicInfo A p Øÿÿÿ   EØŒFŠÚ)Ğq¡Ú        'q¡Úˆÿÿÿnk  ^^ü¡Ú   ˜¯„        ÿÿÿÿÿÿÿÿ   0† 0„ÿÿÿÿ        $          &   {4F2030CE-BA8E-4122-B9A8-29AA5858973E}  àÿÿÿvk l    0†    m Path    àÿÿÿvk     À0†      Hash    øÿÿÿ€~Šhbin 0†                       ÿÿÿ\ M i c r o s o f t \ W i n d o w s \ F l i g h t i n g \ O n e S e t t i n g s \ R e f r e s h C a c h e   Ğÿÿÿ¸/†Ø/†è0†p1†è1†`2†à2†p3†85†˜5†è5†ØÿÿÿæµÒüœåÒĞ±şyºvé³Ì–YU·Órı+KäQ    Ğÿÿÿvk T   1†    \ SecurityDescriptor      ¨ÿÿÿD : P ( A ; ; F A ; ; ; S Y ) ( A ; ; F A ; ; ; B A ) ( A ; ; F R F X ; ; ; A U )   àÿÿÿvk P   1†    \ Source  ¨ÿÿÿ$ ( @ % s y s t e m r o o t % \ s y s t e m 3 2 \ w o s c . d l l , - 6 0 2 )       àÿÿÿvk P   2†    w Author  ¨ÿÿÿ$ ( @ % s y s t e m r o o t % \ s y s t e m 3 2 \ w o s c . d l l , - 6 0 1 )       Øÿÿÿvk P   ˆ2†    b Description     ¨ÿÿÿ$ ( @ % s y s t e m r o o t % \ s y s t e m 3 2 \ w o s c . d l l , - 6 0 3 )       àÿÿÿvk l    3†    e URI     ÿÿÿ\ M i c r o s o f t \ W i n d o w s \ F l i g h t i n g \ O n e S e t t i n g s \ R e f r e s h C a c h e   àÿÿÿvk    3†    m TriggersXşÿÿ        ŞŸéV                ÿÿÿÿÿÿÿÿÀ!BBHHHH‘)ÜHHHH   HHHHL o c a l S y s t e m       HHHH HHHHHHH HHHHHHH   HHHH   HHHH        HHHH    HHHH,   HHHH    ÿÿÿÿ,  ÿÿÿÿ                           HHHHİİ            Ä¾B%Ú                                (P      ÿÿÿÿ             u     6m      HHHHff       ŞŸéV            ŞŸéV   ÿÿÿÿÿÿÿÿ    ÿÿÿÿ                 2 - 4 8 D 9 -     HHHHu8¼£:•            àÿÿÿvk 6   X5†    vActions Àÿÿÿ    L o c a l S y s t e m ww    ÷GvàÒ®ÙH— “›ÂJŠ<          Øÿÿÿvk $   À5†     DynamicInfoàª Øÿÿÿ   NUFŠÚãLÚf¡Ú    â.€^^ü¡Úàÿÿÿvk   €      ê„SchemaËûˆÿÿÿnk  {jş~¡Ú   ˜¯„        ÿÿÿÿÿÿÿÿ	    7† 0„ÿÿÿÿ        $   É      &   {4F41B4A1-8822-4B02-90CD-202A0099FFAE}  àÿÿÿvk Z    6†      Path     ÿÿÿ\ M i c r o s o f t \ W i n d o w s \ D e v i c e   I n f o r m a t i o n \ D e v i c e     Øÿÿÿ€6†(7†p7† 7†(8†¨8†˜:†H;†˜;†àÿÿÿvk     H7†      Hash    Øÿÿÿu.[?ô3€Æ)9Nz’ ·ú1ô?rD9]Xâá    àÿÿÿvk    7†      Version ğÿÿÿ1 . 0       Ğÿÿÿvk R   Ğ7†      SecurityDescriptor      ¨ÿÿÿD : ( A ; ; G A ; ; ; B A ) ( A ; ; G A ; ; ; S Y ) ( A ; ; F R F X ; ; ; L S )     àÿÿÿvk Z   H8†      URI      ÿÿÿ\ M i c r o s o f t \ W i n d o w s \ D e v i c e   I n f o r m a t i o n \ D e v i c e     àÿÿÿvk É  È8†      Triggers0şÿÿ        Ú·             	    ÿÿÿÿÿÿÿÿH!BBHHHH8ÿHHHH   HHHHL o c a l S y s t e m       HHHH HHHHHHH HHHHHHH   HHHH   HHHH        HHHH    HHHH,   HHHH    ÿÿÿÿ F ÿÿÿÿ                           HHHHİİ      	     øÒŞÉ                                €Q     ÿÿÿÿ             vQ      Ê:      HHHHff       Ú·             Ú·    ÿÿÿÿÿÿÿÿ    ÿÿÿÿ                  p e r i e n c *   W N F _ D E P _ O O B E _ C O M P L E T E HHu¼£)–A          àÿÿÿvk †   ¸:†      Actions pÿÿÿ    L o c a l S y s t e m ff    D   % w i n d i r % \ s y s t e m 3 2 \ d e v i c e c e n s u s . e x e    S y s t e m C x t             Øÿÿÿvk $   p;†     DynamicInfo¨¯ Øÿÿÿ   NUFŠÚ²Õq¡Ú        {jş~¡Úàÿÿÿvk   €      ’ Schema ˆÿÿÿnk  òa¤«0Û   ˜¯„        ÿÿÿÿÿÿÿÿ   È<† 0„ÿÿÿÿ        $   è      &   {50DDDD38-168C-486B-966F-A23226488295}  àÿÿÿvk p   P<†      Path    ˆÿÿÿ\ M i c r o s o f t \ W i n d o w s \ C e r t i f i c a t e S e r v i c e s C l i e n t \ S y s t e m T