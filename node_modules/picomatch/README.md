<h1 align="center">Picomatch</h1>

<p align="center">
<a href="https://npmjs.org/package/picomatch">
<img src="https://img.shields.io/npm/v/picomatch.svg" alt="version">
</a>
<a href="https://github.com/micromatch/picomatch/actions?workflow=Tests">
<img src="https://github.com/micromatch/picomatch/workflows/Tests/badge.svg" alt="test status">
</a>
<a href="https://coveralls.io/github/micromatch/picomatch">
<img src="https://img.shields.io/coveralls/github/micromatch/picomatch/master.svg" alt="coverage status">
</a>
<a href="https://npmjs.org/package/picomatch">
<img src="https://img.shields.io/npm/dm/picomatch.svg" alt="downloads">
</a>
</p>

<br>
<br>

<p align="center">
<strong>Blazing fast and accurate glob matcher written in JavaScript.</strong></br>
<em>No dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.</em>
</p>

<br>
<br>

## Why picomatch?

* **Lightweight** - No dependencies
* **Minimal** - Tiny API surface. Main export is a function that takes a glob pattern and returns a matcher function.
* **Fast** - Loads in about 2ms (that's several times faster than a [single frame of a HD movie](http://www.endmemo.com/sconvert/framespersecondframespermillisecond.php) at 60fps)
* **Performant** - Use the returned matcher function to speed up repeat matching (like when watching files)
* **Accurate matching** - Using wildcards (`*` and `?`), globstars (`**`) for nested directories, [advanced globbing](#advanced-globbing) with extglobs, braces, and POSIX brackets, and support for escaping special characters with `\` or quotes.
* **Well tested** - Thousands of unit tests

See the [library comparison](#library-comparisons) to other libraries.

<br>
<br>

## Table of Contents

<details><summary> Click to expand </summary>

- [Install](#install)
- [Usage](#usage)
- [API](#api)
  * [picomatch](#picomatch)
  * [.test](#test)
  * [.matchBase](#matchbase)
  * [.isMatch](#ismatch)
  * [.parse](#parse)
  * [.scan](#scan)
  * [.compileRe](#compilere)
  * [.makeRe](#makere)
  * [.toRegex](#toregex)
- [Options](#options)
  * [Picomatch options](#picomatch-options)
  * [Scan Options](#scan-options)
  * [Options Examples](#options-examples)
- [Globbing features](#globbing-features)
  * [Basic globbing](#basic-globbing)
  * [Advanced globbing](#advanced-globbing)
  * [Braces](#braces)
  * [Matching special characters as literals](#matching-special-characters-as-literals)
- [Library Comparisons](#library-comparisons)
- [Benchmarks](#benchmarks)
- [Philosophies](#philosophies)
- [About](#about)
  * [Author](#author)
  * [License](#license)

_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_

</details>

<br>
<br>

## Install

Install with [npm](https://www.npmjs.com/):

```sh
npm install --save picomatch
```

<br>

## Usage

The main export is a function that takes a glob pattern and an options object and returns a function for matching strings.

```js
const pm = require('picomatch');
const isMatch = pm('*.js');

console.log(isMatch('abcd')); //=> false
console.log(isMatch('a.js')); //=> true
console.log(isMatch('a.md')); //=> false
console.log(isMatch('a/b.js')); //=> false
```

<br>

## API

### [picomatch](lib/picomatch.js#L32)

Creates a matcher function from one or more glob patterns. The returned function takes a string to match as its first argument, and returns true if the string is a match. The returned matcher function also takes a boolean as the second argument that, when true, returns an object with additional information.

**Params**

* `globs` **{String|Array}**: One or more glob patterns.
* `options` **{Object=}**
* `returns` **{Function=}**: Returns a matcher function.

**Example**

```js
const picomatch = require('picomatch');
// picomatch(glob[, options]);

const isMatch = picomatch('*.!(*a)');
console.log(isMatch('a.a')); //=> false
console.log(isMatch('a.b')); //=> true
```

### [.test](lib/picomatch.js#L117)

Test `input` with the given `regex`. This is used by the main `picomatch()` function to test the input string.

**Params**

* `input` **{String}**: String to test.
* `regex` **{RegExp}**
* `returns` **{Object}**: Returns an object with matching info.

**Example**

```js
const picomatch = require('picomatch');
// picomatch.test(input, regex[, options]);

console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
// { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
```

### [.matchBase](lib/picomatch.js#L161)

Match the basename of a filepath.

**Params**

* `input` **{String}**: String to test.
* `glob` **{RegExp|String}**: Glob pattern or regex created by [.makeRe](#makeRe).
* `returns` **{Boolean}**

**Example**

```js
const picomatch = require('picomatch');
// picomatch.matchBase(input, glob[, options]);
console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
```

### [.isMatch](lib/picomatch.js#L183)

Returns true if **any** of the given glob `patterns` match the specified `string`.

**Params**

* **{String|Array}**: str The string to test.
* **{String|Array}**: patterns One or more glob patterns to use for matching.
* **{Object}**: See available [options](#options).
* `returns` **{Boolean}**: Returns true if any patterns match `str`

**Example**

```js
const picomatch = require('picomatch');
// picomatch.isMatch(string, patterns[, options]);

console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
```

### [.parse](lib/picomatch.js#L199)

Parse a glob pattern to create the source string for a regular expression.

**Params**

* `pattern` **{String}**
* `options` **{Object}**
* `returns` **{Object}**: Returns an object with useful properties and output to be used as a regex source string.

**Example**

```js
const picomatch = require('picomatch');
const result = picomatch.parse(pattern[, options]);
```

### [.scan](lib/picomatch.js#L231)

Scan a glob pattern to separate the pattern into segments.

**Params**

* `input` **{String}**: Glob pattern to scan.
* `options` **{Object}**
* `returns` **{Object}**: Returns an object with

**Example**

```js
const picomatch = require('picomatch');
// picomatch.scan(input[, options]);

const result = picomatch.scan('!./foo/*.js');
console.log(result);
{ prefix: '!./',
  input: '!./foo/*.js',
  start: 3,
  base: 'foo',
  glob: '*.js',
  isBrace: false,
  isBracket: false,
  isGlob: true,
  isExtglob: false,
  isGlobstar: false,
  negated: true }
```

### [.compileRe](lib/picomatch.js#L245)

Compile a regular expression from the `state` object returned by the
[parse()](#parse) method.

**Params**

* `state` **{Object}**
* `options` **{Object}**
* `returnOutput` **{Boolean}**: Intended for implementors, this argument allows you to return the raw output from the parser.
* `returnState` **{Boolean}**: Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
* `returns` **{RegExp}**

### [.makeRe](lib/picomatch.js#L286)

Create a regular expression from a parsed glob pattern.

**Params**

* `state` **{String}**: The object returned from the `.parse` method.
* `options` **{Object}**
* `returnOutput` **{Boolean}**: Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
* `returnState` **{Boolean}**: Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
* `returns` **{RegExp}**: Returns a regex created from the given pattern.

**Example**

```js
const picomatch = require('picomatch');
const state = picomatch.parse('*.js');
// picomatch.compileRe(state[, options]);

console.log(picomatch.compileRe(state));
//=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
```

### [.toRegex](lib/picomatch.js#L321)

Create a regular expression from the given regex source string.

**Params**

* `source` **{String}**: Regular expression source string.
* `options` **{Object}**
* `returns` **{RegExp}**

**Example**

```js
const picomatch = require('picomatch');
// picomatch.toRegex(source[, options]);

const { output } = picomatch.parse('*.js');
console.log(picomatch.toRegex(output));
//=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
```

<br>

## Options

### Picomatch options

The following options may be used with the main `picomatch()` function or any of the methods on the picomatch API.

| **Option** | **Type** | **Default value** | **Description** |
| --- | --- | --- | --- |
| `basename`            | `boolean`      | `false`     | If set, then patterns without slashes will be matched against the basename of the path if it contains slashes.  For example, `a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`. |
| `bash`                | `boolean`      | `false`     | Follow bash matching rules more strictly - disallows backslashes as escape characters, and treats single stars as globstars (`**`). |
| `capture`             | `boolean`      | `undefined` | Return regex matches in supporting methods. |
| `contains`            | `boolean`      | `undefined` | Allows glob to match any part of the given string(s). |
| `cwd`                 | `string`       | `process.cwd()` | Current working directory. Used by `picomatch.split()` |
| `debug`               | `boolean`      | `undefined` | Debug regular expressions when an error is thrown. |
| `dot`                 | `boolean`      | `false`     | Enable dotfile matching. By default, dotfiles are ignored unless a `.` is explicitly defined in the pattern, or `options.dot` is true |
| `expandRange`         | `function`     | `undefined` | Custom function for expanding ranges in brace patterns, such as `{a..z}`. The function receives the range values as two arguments, and it must return a string to be used in the generated regex. It's recommended that returned strings be wrapped in parentheses. |
| `failglob`            | `boolean`      | `false`     | Throws an error if no matches are found. Based on the bash option of the same name. |
| `fastpaths`           | `boolean`      | `true`      | To speed up processing, full parsing is skipped for a handful common glob patterns. Disable this behavior by setting this option to `false`. |
| `flags`               | `string`      | `undefined` | Regex flags to use in the generated regex. If defined, the `nocase` option will be overridden. |
| [format](#optionsformat) | `function` | `undefined` | Custom function for formatting the returned string. This is useful for removing leading slashes, converting Windows paths to Posix paths, etc. |
| `ignore`              | `array\|string` | `undefined` | One or more glob patterns for excluding strings that should not be matched from the result. |
| `keepQuotes`          | `boolean`      | `false`     | Retain quotes in the generated regex, since quotes may also be used as an alternative to backslashes.  |
| `literalBrackets`     | `boolean`      | `undefined` | When `true`, brackets in the glob pattern will be escaped so that only literal brackets will be matched. |
| `matchBase`           | `boolean`      | `false`     | Alias for `basename` |
| `maxLength`           | `boolean`      | `65536`     | Limit the max length of the input string. An error is thrown if the input string is longer than this value. |
| `nobrace`             | `boolean`      | `false`     | Disable brace matching, so that `{a,b}` and `{1..3}` would be treated as literal characters. |
| `nobracket`           | `boolean`      | `undefined` | Disable matching with regex brackets. |
| `nocase`              | `boolean`      | `false`     | Make matching case-insensitive. Equivalent to the regex `i` flag. Note that this option is overridden by the `flags` option. |
| `nodupes`             | `boolean`      | `true`      | Deprecated, use `nounique` instead. This option will be removed in a future major release. By default duplicates are removed. Disable uniquification by setting this option to false. |
| `noext`               | `boolean`      | `false`     | Alias for `noextglob` |
| `noextglob`           | `boolean`      | `false`     | Disable support for matching with extglobs (like `+(a\|b)`) |
| `noglobstar`          | `boolean`      | `false`     | Disable support for matching nested directories with globstars (`**`) |
| `nonegate`            | `boolean`      | `false`     | Disable support for negating with leading `!` |
| `noquantifiers`       | `boolean`      | `false`     | Disable support for regex quantifiers (like `a{1,2}`) and treat them as brace patterns to be expanded. |
| [onIgnore](#optionsonIgnore) | `function` | `undefined` | Function to be called on ignored items. |
| [onMatch](#optionsonMatch) | `function` | `undefined` | Function to be called on matched items. |
| [onResult](#optionsonResult) | `function` | `undefined` | Function to be called on all items, regardless of whether or not they are matched or ignored. |
| `posix`               | `boolean`      | `false`     | Support POSIX character classes ("posix brackets"). |
| `posixSlashes`        | `boolean`      | `undefined` | Convert all slashes in file paths to forward slashes. This does not convert slashes in the glob pattern itself |
| `prepend`             | `boolean`      | `undefined` | String to prepend to the generated regex used for matching. |
| `regex`               | `boolean`      | `false`     | Use regular expression rules for `+` (instead of matching literal `+`), and for stars that follow closing parentheses or brackets (as in `)*` and `]*`). |
| `strictBrackets`      | `boolean`      | `undefined` | Throw an error if brackets, braces, or parens are imbalanced. |
| `strictSlashes`       | `boolean`      | `undefined` | When true, picomatch won't match trailing slashes with single stars. |
| `unescape`            | `boolean`      | `undefined` | Remove backslashes preceding escaped characters in the glob pattern. By default, backslashes are retained. |
| `unixify`             | `boolean`      | `undefined` | Alias for `posixSlashes`, for backwards compatibility. |

picomatch has automatic detection for regex positive and negative lookbehinds. If the pattern contains a negative lookbehind, you must be using Node.js >= 8.10 or else picomatch will throw an error.

### Scan Options

In addition to the main [picomatch options](#picomatch-options), the following options may also be used with the [.scan](#scan) method.

| **Option** | **Type** | **Default value** | **Description** |
| --- | --- | --- | --- |
| `tokens` | `boolean` | `false` | When `true`, the returned object will include an array of tokens (objects), representing each path "segment" in the scanned glob pattern |
| `parts` | `boolean` | `false` | When `true`, the returned object will include an array of strings representing each path "segment" in the scanned glob pattern. This is automatically enabled when `options.tokens` is true |

**Example**

```js
const picomatch = require('picomatch');
const result = picomatch.scan('!./foo/*.js', { tokens: true });
console.log(result);
// {
//   prefix: '!./',
//   input: '!./foo/*.js',
//   start: 3,
//   base: 'foo',
//   glob: '*.js',
//   isBrace: false,
//   isBracket: false,
//   isGlob: true,
//   isExtglob: false,
//   isGlobstar: false,
//   negated: true,
//   maxDepth: 2,
//   tokens: [
//     { value: '!./', depth: 0, isGlob: false, negated: true, isPrefix: true },
//     { value: 'foo', depth: 1, isGlob: false },
//     { value: '*.js', depth: 1, isGlob: true }
//   ],
//   slashes: [ 2, 6 ],
//   parts: [ 'foo', '*.js' ]
// }
```

<br>

### Options Examples

#### options.expandRange

**Type**: `function`

**Default**: `undefined`

Custom function for expanding ranges in brace patterns. The [fill-range](https://github.com/jonschlinkert/fill-range) library is ideal for this purpose, or you can use custom code to do whatever you need.

**Example**

The following example shows how to create a glob that matches a folder

```js
const fill = require('fill-range');
const regex = pm.makeRe('foo/{01..25}/bar', {
  expandRange(a, b) {
    return `(${fill(a, b, { toRegex: true })})`;
  }
});

console.log(regex);
//=> /^(?:foo\/((?:0[1-9]|1[0-9]|2[0-5]))\/bar)$/

console.log(regex.test('foo/00/ba0 0 0 0 0 4 6 }         øÿÿÿx/Ûøÿÿÿ˜0Ûøÿÿÿ@1Ûhbin 0Û                       ˆÿÿÿnk   ¤ãsõœÚ   8Ç»       °1Ûÿÿÿÿ   ğ/Û¨1  ÿÿÿÿ            &       &   {FE911807-98C5-11D1-B7F5-0060081C268D}  èÿÿÿvk  &   °0Û       ĞÿÿÿE V i s i o E x t e n d e d D a t a          ÿÿÿnk   ¤ãsõœÚ    0Û        ÿÿÿÿÿÿÿÿ   ø/Û¨1  ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N   X1Û       ¨ÿÿÿ{ 0 0 0 2 0 4 2 0 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         èÿÿÿlh à0Ûc#¡È1ÛüC¶» ÿÿÿnk   ¤ãsõœÚ    0Û        ÿÿÿÿÿÿÿÿ   ˜2Û¨1  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   @2Û       ¨ÿÿÿ{ 0 0 0 2 0 4 2 0 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ(2Ûˆÿÿÿnk  ËãsõœÚ   8Ç»       84Ûÿÿÿÿ   X3Û¨1  ÿÿÿÿ                    &   {FF06FEF2-DA89-41C0-A0A8-5CD434E210AD}  èÿÿÿvk      03Û       ØÿÿÿC h a r t C h a r a c t e r s       øÿÿÿ3Û ÿÿÿnk  ËãsõœÚ    2Û        ÿÿÿÿÿÿÿÿ   04Û¨1  ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N   Ø3Û       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿÀ3Ûàÿÿÿlh `3Ûc#¡X4ÛüC¶»05Û×§ ÿÿÿnk  ËãsõœÚ    2Û        ÿÿÿÿÿÿÿÿ   (5Û¨1  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   Ğ4Û       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ¸4Û¨ÿÿÿnk  ËãsõœÚ    2Û        ÿÿÿÿÿÿÿÿ   ø5Û¨1  ÿÿÿÿ           N          TypeLib èÿÿÿvk  N    5Û     ¶»¨ÿÿÿ{ 0 0 0 2 0 9 0 5 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         ğÿÿÿˆ5Û6Û    àÿÿÿvk    (6Û      Version ğÿÿÿ8 . 7       ˆÿÿÿnk  ËãsõœÚ   8Ç»       À7Ûÿÿÿÿ   à6Û¨1  ÿÿÿÿ                   &   {FF59CFBA-CB6F-4B92-A7D2-97D1CAB6EBFF}  èÿÿÿvk     È6Û       èÿÿÿR e p o r t s       øÿÿÿ°6Û ÿÿÿnk  ËãsõœÚ   86Û        ÿÿÿÿÿÿÿÿ   ¸7Û¨1  ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N   `7Û       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿH7Ûàÿÿÿlh è6Ûc#¡à7ÛüC¶»¸8Û×§ ÿÿÿnk  ËãsõœÚ   86Û        ÿÿÿÿÿÿÿÿ   °8Û¨1  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   X8Û       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ@8Û¨ÿÿÿnk  ËãsõœÚ   86Û        ÿÿÿÿÿÿÿÿ   €9Û¨1  ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   (9Û     ¶»¨ÿÿÿ{ A 7 1 0 7 6 4 0 - 9 4 D F - 1 0 6 8 - 8 5 5 E - 0 0 D D 0 1 0 7 5 4 4 5 }         ğÿÿÿ9Û9Û    àÿÿÿvk    °9Û      Version ğÿÿÿ4 . 9       ˜ÿÿÿnk  òãsõœÚ   h”       ø:Ûÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ
                      IPM.Note.Mobile.MMS     ¨ÿÿÿnk  òãsõœÚ   À9Û        ÿÿÿÿÿÿÿÿ   ğ:Û¨1  ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   ˜:Û       ¨ÿÿÿ{ 3 C 1 5 C 5 B 1 - 7 3 6 D - 4 C F 0 - 8 5 E 3 - 2 3 F 4 E 2 3 A 6 D F 0 }         øÿÿÿ€:Ûğÿÿÿlh (:Û[‹¸˜ÿÿÿnk   äsõœÚ   h”       @<Ûÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ
                      IPM.Note.Mobile.SMS     ¨ÿÿÿnk   äsõœÚ   ;Û        ÿÿÿÿÿÿÿÿ   8<Û¨1  ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   à;Û       ¨ÿÿÿ{ 3 C 1 5 C 5 B 1 - 7 3 6 D - 4 C F 0 - 8 5 E 3 - 2 3 F 4 E 2 3 A 6 D F 0 }         øÿÿÿÈ;Ûğÿÿÿlh p;Û[‹¸¨ÿÿÿnk   äsõœÚ   h”       ø>Ûÿÿÿÿ   =Û¨1  ÿÿÿÿ           ‚          iqyfile èÿÿÿvk  >   À<Û       ¸ÿÿÿM i c r o s o f t   E x c e l   W e b   Q u e r y   F i l e         ğÿÿÿ¨<Û=Û@=ÛØÿÿÿvk	   €          EditFlags       Øÿÿÿvk ‚   h=Û      FriendlyTypeNamexÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 1 9 0      ÿÿÿnk   äsõœÚ   P<Û        ÿÿÿÿÿÿÿÿ   ğ>Û¨1  ÿÿÿÿ            ~          DefaultIcon     èÿÿÿvk  ~   h>Û       xÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   O f f i c e \ r o o t \ O f f i c e 1 6 \ E X C E L . E X E , - 2 7 0         øÿÿÿP>Ûèÿÿÿlh ğ=Ûæùoà?Û¸~	¨ÿÿÿnk   äsõœÚ   P<Û       ø@Ûÿÿÿÿ   ?Û¨1  ÿÿÿÿ*           
          Shell   èÿÿÿvk  
   €?Û       ğÿÿÿo p e n   oàøÿÿÿh?Û˜ÿÿÿnk   äsõœÚ   ?Û       àAÛÿÿÿÿ   À@Û¨1  ÿÿÿÿ          €          Edit_Query_in_Notepad   hbin @Û                       èÿÿÿvk  €   8@Û       xÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 1 5       ğÿÿÿ @ÛĞ@Û    Øÿÿÿvk	   €         EditFlags       èÿÿÿlh ˜?ÛãZP¦ğAÛJÅ> ¨ÿÿÿnk   äsõœÚ   ˜?Û        ÿÿÿÿÿÿÿÿ   ØAÛ¨1  ÿÿÿÿ            N          command èÿÿÿvk  N   €AÛ       ¨ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ n o t e p a d . e x e   " % 1 "         øÿÿÿhAÛğÿÿÿlh AÛoŸU¨ÿÿÿnk   äsõœÚ   ?Û        DÛÿÿÿÿ   èBÛ¨1  ÿÿÿÿ          €          open    èÿÿÿvk  €   `BÛ       xÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 1 2       ğÿÿÿHBÛøBÛ    Øÿÿÿvk	   €         EditFlags       ¨ÿÿÿnk   äsõœÚ   ğAÛ        ÿÿÿÿÿÿÿÿ   DÛ¨1  ÿÿÿÿ            ~          command èÿÿÿvk  ~   CÛ       xÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   O f f i c e \ r o o t \ O f f i c e 1 6 \ E X C E L . E X E   " % 1 "         øÿÿÿxCÛèÿÿÿlh  CÛoŸU8DÛRD+À¨ÿÿÿnk   äsõœÚ   ğAÛ        ÿÿÿÿÿÿÿÿ   ¨DÛ¨1  ÿÿÿÿ                      ddeexec èÿÿÿvk    €           øÿÿÿDÛ¨ÿÿÿnk   äsõœÚ   h”       hFÛÿÿÿÿ   HEÛ¨1  ÿÿÿÿ                      LEXFile èÿÿÿvk       EÛ       ØÿÿÿD i c t i o n a r y   F i l e       øÿÿÿEÛ ÿÿÿnk   äsõœÚ   °DÛ        ÿÿÿÿÿÿÿÿ   `FÛ¨1  ÿÿÿÿ                      DefaultIcon     èÿÿÿvk     ÈEÛ       hÿÿÿC : \ P r o g r a m   F i l e s \ C o m m o n   F i l e s \ M i c r o s o f t   S h a r e d \ O F F I C E 1 6 \ M S O I C O N S . E X E , 6         øÿÿÿ°EÛğÿÿÿlh PEÛæùoà¨ÿÿÿnk  *@äsõœÚ   h”       ¸GÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿH                      Licensesˆÿÿÿnk   äsõœÚ   xFÛ        ÿÿÿÿÿÿÿÿ   °GÛ¨1  ÿÿÿÿ            J       $   4F86BADF-9F77-11d1-B1B7-0000F8753F5D    èÿÿÿvk  J   `GÛ       °ÿÿÿi p l p w p n i p p o p u p i i v j r i o p p i s j s j l p i i o k u j     øÿÿÿHGÛØÿÿÿlh ĞFÛ1ñC—àGÛy\˜IÛ0ü€JÛ—áˆÿÿÿnk  *@äsõœÚ   xFÛ       °HÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                   $   73A4C9C1-D68D-11d0-98BF-00A0C90DC8D9    ¨ÿÿÿnk  *@äsõœÚ   àGÛ       ˆIÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                      16.0    ğÿÿÿlh XHÛé' ¨ÿÿÿnk  *@äsõœÚ   XHÛ        ÿÿÿÿÿÿÿÿ   €IÛ¨1  ÿÿÿÿ            J          Retail  èÿÿÿvk  J   0IÛ       °ÿÿÿs b b c d c p r k t p j t a p m m f d a c m u p a s b h s c d d n c g p     øÿÿÿIÛğÿÿÿlh ÀHÛ%$äZˆÿÿÿnk  *@äsõœÚ   xFÛ        ÿÿÿÿÿÿÿÿ   xJÛ¨1  ÿÿÿÿ            J       $   DC4D7920-6AC8-11cf-8ADB-00AA00C00905    èÿÿÿvk  J   (JÛ     \°ÿÿÿi o k o u h l o o h r o j h h h t n o o i o k o m i w n m o h o s m s l     øÿÿÿJÛˆÿÿÿnk  *@äsõœÚ   xFÛ        ÿÿÿÿÿÿÿÿ   `KÛ¨1  ÿÿÿÿ            J       $   ED4B87C4-9F76-11d1-8BF7-0000F8754DA1    èÿÿÿvk  J   KÛ       °ÿÿÿk n l g g n m n t g g g r n i n t h p g m n n g r h q h n n j n s l s h     øÿÿÿøJÛ ÿÿÿnk  *@äsõœÚ   h”        LÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                      Local Settings  ¨ÿÿÿnk  *@äsõœÚ   hKÛ       LÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                      Softwareğÿÿÿlh ÈKÛcşé ÿÿÿnk  *@äsõœÚ   ÈKÛ       øLÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                   	   Microsoft       ğÿÿÿlh 0LÛ&Í ¨ÿÿÿnk  *@äsõœÚ   0LÛ       `MÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ
                      Windows ğÿÿÿlh  LÛ‹æ}/¨ÿÿÿnk  *@äsõœÚ    LÛ       ÈMÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                      Shell   ğÿÿÿlh MÛ¸~	¨ÿÿÿnk  *@äsõœÚ   MÛ       0NÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                      Bags    ğÿÿÿlh pMÛ)i4 ¨ÿÿÿnk  *@äsõœÚ   pMÛ       ĞNÛÿÿÿÿ    ÿÿÿÿ¨1  ÿÿÿÿ                      66      ğÿÿÿlh ØMÛ  ¨ÿÿÿnk  *@äsõœÚ   ØMÛ        ÿÿÿÿÿÿÿÿ   ÈNÛ¨1  ÿÿÿÿ        .             ComDlg  Ğÿÿÿvk   €	         ScrollPos1280x1024(2).y øÿÿÿ˜NÛğÿÿÿlh @NÛ~2ıÿÿÿnk  *@äsõœÚ   h”       ĞOÛÿÿÿÿ   ¨OÛ¨1  ÿÿÿÿ           :          LR.LexRefBilingualService.1.0   èÿÿÿvk  :   hOÛ       ÀÿÿÿL e x R e f B i l i n g u a l S e r v i c e   C l a s s     øÿÿÿPOÛèÿÿÿvk  N   xPÛ       øÿÿÿ°OÛèÿÿÿlh  PÛ[‹¸ĞPÛ¿­èÿÿÿvk  @   (QÛ       hbin PÛ                       ¨ÿÿÿnk  *@äsõœÚ   àNÛ        ÿÿÿÿÿÿÿÿ   ÈOÛ¨1  ÿÿÿÿ            N          CLSID   ¨ÿÿÿ{ 7 5 C 1 1 6 0 4 - 5 C 5 1 - 4 8 B 2 - B 7 8 6 - D F 5 E 5 1 D 1 0 E C 6 }         ¨ÿÿÿnk  *@äsõœÚ   àNÛ        ÿÿÿÿÿÿÿÿ   pQÛ¨1  ÿÿÿÿ            @          CurVer  ¸ÿÿÿL R . L e x R e f B i l i n g u a l S e r v i c e . 1 . 0 . 1       øÿÿÿèOÛÿÿÿnk  *@äsõœÚ   h”       SÛÿÿÿÿ   @RÛ¨1  ÿÿÿÿ
           :          LR.LexRefBilingualService.1.0.1 èÿÿÿvk  :    RÛ       ÀÿÿÿL e x R e f B i l i n g u a l S e r v i c e   C l a s s     øÿÿÿèQÛ¨ÿÿÿnk  *@äsõœÚ   xQÛ        ÿÿÿÿÿÿÿÿ   SÛ¨1  ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   ¸RÛ       ¨ÿÿÿ{ 7 5 C 1 1 6 0 4 - 5 C 5 1 - 4 8 B 2 - B 7 8 6 - D F 5 E 5 1 D 1 0 E C 6 }         øÿÿÿ RÛğÿÿÿlh HRÛ[‹¸ˆÿÿÿnk  4gäsõœÚ   h”       àTÛÿÿÿÿ   TÛ¨1  ÿÿÿÿ           L       &   LR.LexRefBilingualServiceAttribute.1.0  èÿÿÿvk  L   ¸SÛ       °ÿÿÿL e x R e f B i l i n g u a l S e r v i c e A t t r i b u t e   C l a s s   øÿÿÿ SÛ¨ÿÿÿnk  4gäsõœÚ   (SÛ        ÿÿÿÿÿÿÿÿ   ØTÛ¨1  ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   €TÛ       ¨ÿÿÿ{ A B F 6 5 1 A 1 - 0 F 0 7 - 4 8 D F - 9 F F 6 - 8 B 1 B 5 5 7 6 6 9 C A }         øÿÿÿhTÛèÿÿÿlh TÛ[‹¸øTÛ¿­¨ÿÿÿnk  4gäsõœÚ   (SÛ        ÿÿÿÿÿÿÿÿ   ÀUÛ¨1  ÿÿÿÿ            R          CurVer  èÿÿÿvk  R   hUÛ       ¨ÿÿÿL R . L e x R e f B i l i n g u a l S e r v i c e A t t r i b u t e . 1 . 0 . 1     øÿÿÿPUÛˆÿÿÿnk  4gäsõœÚ   h”       €WÛÿÿÿÿ   ¨VÛ¨1  ÿÿÿÿ
           L       (   LR.LexRefBilingualServiceAttribute.1.0.1èÿÿÿvk  L   XVÛ       °ÿÿÿL e x R e f B i l i n g u a l S e r v i c e A t t r i b u t e   C l a s s   øÿÿÿ@VÛ¨ÿÿÿnk  4gäsõœÚ   ÈUÛ        ÿÿÿÿÿÿÿÿ   xWÛ¨1  ÿÿÿÿ            N          CLSID   èÿÿÿvk  N    WÛ       ¨ÿÿÿ{ A B F 6 5 1 A 1 - 0 F 0 7 - 4 8 D F - 9 F F 6 - 8 B 1 B 5 5 7 6 6 9 C A }         øÿÿÿWÛğÿÿÿlh °VÛ[‹¸ˆÿÿÿnk  4gäsõœÚ   h”       @YÛÿÿÿÿ   hXÛ¨1  ÿÿÿÿ           B       !   LR.LexRefBilingualTextContext.1.0       èÿÿÿvk  B    XÛ       ¸ÿÿÿL e x R e f B i l i n g u a l T e x t C o n t e x t   C l a s s     øÿÿÿXÛ¨ÿÿÿnk  4gäsõœÚ   WÛ        ÿÿÿÿÿÿÿÿ   8YÛ¨1  ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   àXÛ       ¨ÿÿÿ{ 7 5 C 1 1 6 0 4 - 5 C 5 1 - 4 8 B 2 - B 7 8 6 - D F 5 E 5 1 D 1 0 E C 9 }         øÿÿÿÈXÛèÿÿÿlh pXÛ[‹¸XYÛ¿­¨ÿÿÿnk  4gäsõœÚ   WÛ        ÿÿÿÿÿÿÿÿ   ZÛ¨1  ÿÿÿÿ            H          CurVer  èÿÿÿvk  H   ÈYÛ       °ÿÿÿL R . L e x R e f B i l i n g u a l T e x t C o n t e x t . 1 . 0 . 1       øÿÿÿ°YÛˆÿÿÿnk  4gäsõœÚ   h”       Ğ[Ûÿÿÿÿ   øZÛ¨1  ÿÿÿÿ
           B       #   LR.LexRefBilingualTextContext.1.0.1     èÿÿÿvk  B   °ZÛ       ¸ÿÿÿL e x R e f B i l i n g u a l T e x t C o n t e x t   C l a s s     øÿÿÿ˜ZÛ¨ÿÿÿn