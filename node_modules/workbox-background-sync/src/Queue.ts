/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {WorkboxError} from 'workbox-core/_private/WorkboxError.js';
import {logger} from 'workbox-core/_private/logger.js';
import {assert} from 'workbox-core/_private/assert.js';
import {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.js';
import {QueueStore} from './lib/QueueStore.js';
import {QueueStoreEntry, UnidentifiedQueueStoreEntry} from './lib/QueueDb.js';
import {StorableRequest} from './lib/StorableRequest.js';
import './_version.js';

// Give TypeScript the correct global.
declare let self: ServiceWorkerGlobalScope;

interface OnSyncCallbackOptions {
  queue: Queue;
}

interface OnSyncCallback {
  (options: OnSyncCallbackOptions): void | Promise<void>;
}

export interface QueueOptions {
  forceSyncFallback?: boolean;
  maxRetentionTime?: number;
  onSync?: OnSyncCallback;
}

interface QueueEntry {
  request: Request;
  timestamp?: number;
  // We could use Record<string, unknown> as a type but that would be a breaking
  // change, better do it in next major release.
  // eslint-disable-next-line  @typescript-eslint/ban-types
  metadata?: object;
}

const TAG_PREFIX = 'workbox-background-sync';
const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes

const queueNames = new Set<string>();

/**
 * Converts a QueueStore entry into the format exposed by Queue. This entails
 * converting the request data into a real request and omitting the `id` and
 * `queueName` properties.
 *
 * @param {UnidentifiedQueueStoreEntry} queueStoreEntry
 * @return {Queue}
 * @private
 */
const convertEntry = (
  queueStoreEntry: UnidentifiedQueueStoreEntry,
): QueueEntry => {
  const queueEntry: QueueEntry = {
    request: new StorableRequest(queueStoreEntry.requestData).toRequest(),
    timestamp: queueStoreEntry.timestamp,
  };
  if (queueStoreEntry.metadata) {
    queueEntry.metadata = queueStoreEntry.metadata;
  }
  return queueEntry;
};

/**
 * A class to manage storing failed requests in IndexedDB and retrying them
 * later. All parts of the storing and replaying process are observable via
 * callbacks.
 *
 * @memberof workbox-background-sync
 */
class Queue {
  private readonly _name: string;
  private readonly _onSync: OnSyncCallback;
  private readonly _maxRetentionTime: number;
  private readonly _queueStore: QueueStore;
  private readonly _forceSyncFallback: boolean;
  private _syncInProgress = false;
  private _requestsAddedDuringSync = false;

  /**
   * Creates an instance of Queue with the given options
   *
   * @param {string} name The unique name for this queue. This name must be
   *     unique as it's used to register sync events and store requests
   *     in IndexedDB specific to this instance. An error will be thrown if
   *     a duplicate name is detected.
   * @param {Object} [options]
   * @param {Function} [options.onSync] A function that gets invoked whenever
   *     the 'sync' event fires. The function is invoked with an object
   *     containing the `queue` property (referencing this instance), and you
   *     can use the callback to customize the replay behavior of the queue.
   *     When not set the `replayRequests()` method is called.
   *     Note: if the replay fails after a sync event, make sure you throw an
   *     error, so the browser knows to retry the sync event later.
   * @param {number} [options.maxRetentionTime=7 days] The amount of time (in
   *     minutes) a request may be retried. After this amount of time has
   *     passed, the request will be deleted from the queue.
   * @param {boolean} [options.forceSyncFallback=false] If `true`, instead
   *     of attempting to use background sync events, always attempt to replay
   *     queued request at service worker startup. Most folks will not need
   *     this, unless you explicitly target a runtime like Electron that
   *     exposes the interfaces for background sync, but does not have a working
   *     implementation.
   */
  constructor(
    name: string,
    {forceSyncFallback, onSync, maxRetentionTime}: QueueOptions = {},
  ) {
    // Ensure the store name is not already being used
    if (queueNames.has(name)) {
      throw new WorkboxError('duplicate-queue-name', {name});
    } else {
      queueNames.add(name);
    }

    this._name = name;
    this._onSync = onSync || this.replayRequests;
    this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;
    this._forceSyncFallback = Boolean(forceSyncFallback);
    this._queueStore = new QueueStore(this._name);

    this._addSyncListener();
  }

  /**
   * @return {string}
   */
  get name(): string {
    return this._name;
  }

  /**
   * Stores the passed request in IndexedDB (with its timestamp and any
   * metadata) at the end of the queue.
   *
   * @param {QueueEntry} entry
   * @param {Request} entry.request The request to store in the queue.
   * @param {Object} [entry.metadata] Any metadata you want associated with the
   *     stored request. When requests are replayed you'll have access to this
   *     metadata object in case you need to modify the request beforehand.
   * @param {number} [entry.timestamp] The timestamp (Epoch time in
   *     milliseconds) when the request was first added to the queue. This is
   *     used along with `maxRetentionTime` to remove outdated requests. In
   *     general you don't need to set this value, as it's automatically set
   *     for you (defaulting to `Date.now()`), but you can update it if you
   *     don't want particular requests to expire.
   */
  async pushRequest(entry: QueueEntry): Promise<void> {
    if (process.env.NODE_ENV !== 'production') {
      assert!.isType(entry, 'object', {
        moduleName: 'workbox-background-sync',
        className: 'Queue',
        funcName: 'pushRequest',
        paramName: 'entry',
      });
      assert!.isInstance(entry.request, Request, {
        moduleName: 'workbox-background-sync',
        className: 'Queue',
        funcName: 'pushRequest',
        paramName: 'entry.request',
      });
    }

    await this._addRequest(entry, 'push');
  }

  /**
   * Stores the passed request in IndexedDB (with its timestamp and any
   * metadata) at the beginning of the queue.
   *
   * @param {QueueEntry} entry
   * @param {Request} entry.request The request to store in the queue.
   * @param {Object} [entry.metadata] Any metadata you want associated with the
   *     stored request. When requests are replayed you'll have access to this
   *     metadata object in case you need to modify the request beforehand.
   * @param {number} [entry.timestamp] The timestamp (Epoch time in
   *     milliseconds) when the request was first added to the queue. This is
   *     used along with `maxRetentionTime` to remove outdated requests. In
   *     general you don't need to set this value, as it's automatically set
   *     for you (defaulting to `Date.now()`), but you can update it if you
   *     don't want particular requests to expire.
   */
  async unshiftRequest(entry: QueueEntry): Promise<void> {
    if (process.env.NODE_ENV !== 'production') {
      assert!.isType(entry, 'object', {
        moduleName: 'workbox-background-sync',
        className: 'Queue',
        funcName: 'unshiftRequest',
        paramName: 'entry',
      });
      assert!.isInstance(entry.request, Request, {
        moduleName: 'workbox-background-sync',
        className: 'Queue',
        funcName: 'unshiftRequest',
        paramName: 'entry.request',
      });
    }

    await this._addRequest(entry, 'unshift');
  }

  /**
   * Removes and returns the last request in the queue (along with its
   * timestamp and any metadata). The returned object takes the form:
   * `{request, timestamp, metadata}`.
   *
   * @return {Promise<QueueEntry | undefined>}
   */
  async popRequest(): Promise<QueueEntry | undefined> {
    return this._removeRequest('pop');
  }

  /**
   * Removes and returns the first request in the queue (along with its
   * timestamp and any metadata). The returned object takes the form:
   * `{request, timestamp, metadata}`.
   *
   * @return {Promise<QueueEntry | undefined>}
   */
  async shiftRequest(): Promise<QueueEntry | undefined> {
    return this._removeRequest('shift');
  }

  /**
   * Returns all the entries that have not expired (per `maxRetentionTime`).
   * Any expired entries are removed from the queue.
   *
   * @return {Promise<Array<QueueEntry>>}
   */
  async getAll(): Promise<Array<QueueEntry>> {
    const allEntries = await this._queueStore.getAll();
    const now = Date.now();

    const unexpiredEntries = [];
    for (const entry of allEntries) {
      // Ignore requests older than maxRetentionTime. Call this function
      // recursively until an unexpired request is found.
      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;
      if (now - entry.timestamp > maxRetentionTimeInMs) {
        await this._queueStore.deleteEntry(entry.id);
      } else {
        unexpiredEntries.push(convertEntry(entry));
      }
    }

    return unexpiredEntries;
  }

  /**
   * Returns the number of entries present in the queue.
   * Note that expired entries (per `maxRetentionTime`) are also included in this count.
   *
   * @return {Promise<number>}
   */
  async size(): Promise<number> {
    return await this._queueStore.size();
  }

  /**
   * Adds the entry to the QueueStore and registers for a sync event.
   *
   * @param {Object} entry
   * @param {Request} entry.request
   * @param {Object} [entry.metadata]
   * @param {number} [entry.timestamp=Date.now()]
   * @param {string} operation ('push' or 'unshift')
   * @private
   */
  async _addRequest(
    {request, metadata, timestamp = Date.now()}: QueueEntry,
    operation: 'push' | 'unshift',
  ): Promise<void> {
    const storableRequest = await StorableRequest.fromRequest(request.clone());
    const entry: UnidentifiedQueueStoreEntry = {
      requestData: storableRequest.toObject(),
      timestamp,
    };

    // Only include metadata if it's present.
    if (metadata) {
      entry.metadata = metadata;
    }

    switch (operation) {
      case 'push':
        await this._queueStore.pushEntry(entry);
        break;
      case 'unshift':
        await this._queueStore.unshiftEntry(entry);
        break;
    }

    if (process.env.NODE_ENV !== 'production') {
      logger.log(
        `Request for '${getFriendlyURL(request.url)}' has ` +
          `been added to background sync queue '${this._name}'.`,
      );
    }

    // Don't register for a sync if we're in the middle of a sync. Instead,
    // we wait until the sync is complete and call register if
    // `this._requestsAddedDuringSync` is true.
    if (this._syncInProgress) {
      this._requestsAddedDuringSync = true;
    } else {
      await this.registerSync();
    }
  }

  /**
   * Removes and returns the first or last (depending on `operation`) entry
   * from the QueueStore that's not older than the `maxRetentionTime`.
   *
   * @param {string} operation ('pop' or 'shift')
   * @return {Object|undefined}
   * @private
   */
  async _removeRequest(
    operation: 'pop' | 'shift',
  ): Promise<QueueEntry | undefined> {
    const now = Date.now();
    let entry: QueueStoreEntry | undefined;
    switch (operation) {
      case 'pop':
        entry = await this._queueStore.popEntry();
        break;
      case 'shift':
        entry = await this._queueStore.shiftEntry();
        break;
    }

    if (entry) {
      // Ignore requests older than maxRetentionTime. Call this function
      // recursively until an unexpired request is found.
      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;
      if (now - entry.timestamp > maxRetentionTimeInMs) {
        return this._removeRequest(operation);
      }

      return convertEntry(entry);
    } else {
      return undefined;
    }
  }

  /**
   * Loops through each request in the queue and attempts to re-fetch it.
   * If any request fails to re-fetch, it's put back in the same position in
   * the queue (which registers a retry for the next sync event).
   */
  async replayRequests(): Promise<void> {
    let entry;
    while ((       ğÿÿÿÀ__h`_    ğÿÿÿB o t h     øÿÿÿè`_hbin `_                       ¸ÿÿÿ% s y s t e m r o o t % \ s y s t e m 3 2 \ s h e l l 3 2 . d l l   Øÿÿÿvk 
   è__      ThreadingModel  ¨ÿÿÿnk  ¢"MàŞ¬Õ    ]_       €b_ÿÿÿÿ   ø__Î ÿÿÿÿ       
   N          Instanceàÿÿÿvk N   a_      CLSID   ¨ÿÿÿ{ 0 E 5 A A E 1 1 - A 4 7 5 - 4 c 5 b - A B 0 0 - C 6 6 D E 4 0 0 2 7 4 E }          ÿÿÿnk  ¢"MàŞ¬Õ   `_        ÿÿÿÿÿÿÿÿ   èa_Î ÿÿÿÿ        "   N          InitPropertyBag Øÿÿÿvk
   €         Attributes      ğÿÿÿÀa_øa_    Ğÿÿÿvk N   (b_      TargetKnownFolder       ¨ÿÿÿ{ 1 8 9 8 9 B 1 D - 9 9 B 5 - 4 5 5 B - 8 4 1 C - A B 7 C 7 4 E 4 D D F C }         ğÿÿÿlh `a_ËV4Ã ÿÿÿnk  ¢"MàŞ¬Õ    ]_        ÿÿÿÿÿÿÿÿ   c_Î ÿÿÿÿ                      ShellFolder     Øÿÿÿvk
   €M €ğ    ÂËAttributes      ğÿÿÿğb_(c_Pc_Øÿÿÿvk   €)        €FolderValueFlagsØÿÿÿvk   €         SortOrderIndex  ˆÿÿÿnk  ¢"MàŞ¬Õ   `G'       Pd_ÿÿÿÿ    ÿÿÿÿğ‚  ÿÿÿÿ                   &   {A09CCA86-27BA-4F39-9053-121FA4DC08FC}   ÿÿÿnk  ¢"MàŞ¬Õ   xc_        ÿÿÿÿÿÿÿÿ    ÿÿÿÿè1¢ ÿÿÿÿ                    
   Containers      èÿÿÿlh ğc_v³^“hd_CÇÚ ÿÿÿnk  ¢"MàŞ¬Õ   xc_        ÿÿÿÿÿÿÿÿ   8e_Î ÿÿÿÿ           P          InProcServer32  èÿÿÿvk  P   àd_       ¨ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ w i n d o w s c o d e c s . d l l       ğÿÿÿÈd_He_    Øÿÿÿvk 
   pe_      ThreadingModel  ğÿÿÿB o t h     ˆÿÿÿnk  -¢ä¬Õ   `G'       Pg_ÿÿÿÿ   Hf_ğ‚  ÿÿÿÿ           4       &   {A0A7A57B-59B2-4919-A694-ADD0A526C373}  èÿÿÿvk  4   f_      ÈÿÿÿT e a r l e s s   W i n d o w   P r e s e n t e r   øÿÿÿøe_ ÿÿÿnk  íË§·ÃŠÚ   €e_        ÿÿÿÿÿÿÿÿ   g_Î ÿÿÿÿ           8          InprocServer32  èÿÿÿvk  8   Èf_     ËÀÿÿÿC : \ W i n d o w s \ S y s W O W 6 4 \ e v r . d l l       ğÿÿÿ°f_g_    Øÿÿÿvk 
   @g_      ThreadingModel  ğÿÿÿB o t h     ğÿÿÿlh Pf_CÇÚˆÿÿÿnk  ¢"MàŞ¬Õ   `G'       Pi_ÿÿÿÿ   8h_ğ‚  ÿÿÿÿ           D       &   {A0A8C450-92FC-422a-AA04-0A19E8D65AC7}  èÿÿÿvk  D   ğg_       ¸ÿÿÿT y p e A h e a d   L o c a l   M e t a d a t a   P r o v i d e r   øÿÿÿØg_ ÿÿÿnk  ¢"MàŞ¬Õ   `g_        ÿÿÿÿÿÿÿÿ    i_Î ÿÿÿÿ           D          InProcServer32  èÿÿÿvk  D   ¸h_       ¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ s h e l l 3 2 . d l l   ğÿÿÿ h_i_    Øÿÿÿvk    8i_    ( ThreadingModel  èÿÿÿA p a r t m e n t   ğÿÿÿlh @h_CÇÚˆÿÿÿnk  •¿lç5Ú   `G'       èj_ÿÿÿÿ    ÿÿÿÿ0  ÿÿÿÿ                   &   {A0ABC02B-D279-4FA3-9D37-199D4D3F8152}   ÿÿÿnk  íË§·ÃŠÚ   `i_        ÿÿÿÿÿÿÿÿ    j_Î ÿÿÿÿ           F          InprocServer32  èÿÿÿvk  F   Pj_       °ÿÿÿC : \ W i n d o w s \ S y s W O W 6 4 \ U i a M a n a g e r . d l l         ğÿÿÿ8j_°j_    Øÿÿÿvk 
   Øj_      ThreadingModel  ğÿÿÿB o t h     ğÿÿÿlh Øi_CÇÚˆÿÿÿnk  3JKàŞ¬Õ   `G'        m_ÿÿÿÿ   l_ğ‚  ÿÿÿÿ           v       &   {A0B9B497-AFBC-45AD-A8A6-9B077C40D4F2}  èÿÿÿvk  v   ˆk_      €ÿÿÿC u s t o m   C o m p o s i t i o n   S e g m e n t   f r o m   E n c o d e r   t o   T i m e   S h i f t   S i n k         øÿÿÿpk_ ÿÿÿnk  íË§·ÃŠÚ   øj_        ÿÿÿÿÿÿÿÿ   Ğl_Î ÿÿÿÿ           B          InprocServer32  èÿÿÿvk  B   ˆl_       ¸ÿÿÿC : \ W i n d o w s \ S y s W O W 6 4 \ m s v i d c t l . d l l     ğÿÿÿpl_àl_    Øÿÿÿvk    m_    ÂËThreadingModel  èÿÿÿA p a r t m e n t   ğÿÿÿlh l_CÇÚˆÿÿÿnk  3JKàŞ¬Õ   `G'       xn_ÿÿÿÿ   n_ğ‚  ÿÿÿÿ0           T       &   {A0C63C30-F08D-4AB4-907C-34905D770C7D}  èÿÿÿvk  T   Àm_       ¨ÿÿÿM i c r o s o f t   R D P   C l i e n t   C o n t r o l   -   v e r s i o n   1 1   øÿÿÿ¨m_¨ÿÿÿnk  3JKàŞ¬Õ   0m_        ÿÿÿÿÿÿÿÿ    ÿÿÿÿÎ ÿÿÿÿ                       Control ¸ÿÿÿlh  n_dÁUÀn_CÇÚ p_Éßq_uõT¸q_Õ—Rr_×§èr_ât…†ps_sQ ÿÿÿnk  3JKàŞ¬Õ   0m_        ÿÿÿÿÿÿÿÿ   €o_Î ÿÿÿÿ           D          InprocServer32  èÿÿÿvk  D   8o_       ¸ÿÿÿ% s y s t e m r o o t % \ s y s t e m 3 2 \ m s t s c a x . d l l   ğÿÿÿ o_o_    Øÿÿÿvk    ¸o_    ÂËThreadingModel  èÿÿÿA p a r t m e n t   èÿÿÿvk    €0         øÿÿÿĞo_øÿÿÿØp_øÿÿÿpq_hbin p_             