"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const __1 = require("..");
const codegen_1 = require("../codegen");
const ref_error_1 = require("../ref_error");
const names_1 = require("../names");
const code_1 = require("../../vocabularies/code");
const ref_1 = require("../../vocabularies/jtd/ref");
const type_1 = require("../../vocabularies/jtd/type");
const parseJson_1 = require("../../runtime/parseJson");
const util_1 = require("../util");
const timestamp_1 = require("../../runtime/timestamp");
const genParse = {
    elements: parseElements,
    values: parseValues,
    discriminator: parseDiscriminator,
    properties: parseProperties,
    optionalProperties: parseProperties,
    enum: parseEnum,
    type: parseType,
    ref: parseRef,
};
function compileParser(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const parseName = gen.scopeName("parse");
    const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
        parseName,
        char: gen.name("c"),
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        sch.parseName = parseName;
        parserFunction(cxt);
        gen.optimize(this.opts.code.optimize);
        const parseFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
        const parse = makeParse(this.scope.get());
        this.scope.value(parseName, { ref: parse });
        sch.parse = parse;
    }
    catch (e) {
        if (sourceCode)
            this.logger.error("Error compiling parser, function code:", sourceCode);
        delete sch.parse;
        delete sch.parseName;
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
    return sch;
}
exports.default = compileParser;
const undef = (0, codegen_1._) `undefined`;
function parserFunction(cxt) {
    const { gen, parseName, char } = cxt;
    gen.func(parseName, (0, codegen_1._) `${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
        gen.let(names_1.default.data);
        gen.let(char);
        gen.assign((0, codegen_1._) `${parseName}.message`, undef);
        gen.assign((0, codegen_1._) `${parseName}.position`, undef);
        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos} || 0`);
        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json}.length`);
        parseCode(cxt);
        skipWhitespace(cxt);
        gen.if(names_1.default.jsonPart, () => {
            gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
            gen.return(names_1.default.data);
        });
        gen.if((0, codegen_1._) `${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
        jsonSyntaxError(cxt);
    });
}
function parseCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
            form = key;
            break;
        }
    }
    if (form)
        parseNullable(cxt, genParse[form]);
    else
        parseEmpty(cxt);
}
const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
function parseNullable(cxt, parseForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
        return parseForm(cxt);
    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
}
function parseElements(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "[");
    const ix = gen.let("i", 0);
    gen.assign(data, (0, codegen_1._) `[]`);
    parseItems(cxt, "]", () => {
        const el = gen.let("el");
        parseCode({ ...cxt, schema: schema.elements, data: el });
        gen.assign((0, codegen_1._) `${data}[${ix}++]`, el);
    });
}
function parseValues(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{}`);
    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
}
function parseItems(cxt, endToken, block) {
    tryParseItems(cxt, endToken, block);
    parseToken(cxt, endToken);
}
function tryParseItems(cxt, endToken, block) {
    const { gen } = cxt;
    gen.for((0, codegen_1._) `;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
        block();
        tryParseToken(cxt, ",", () => gen.break(), hasItem);
    });
    function hasItem() {
        tryParseToken(cxt, endToken, () => { }, jsonSyntaxError);
    }
}
function parseKeyValue(cxt, schema) {
    const { gen } = cxt;
    const key = gen.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
}
function parseDiscriminator(cxt) {
    const { gen, data, schema } = cxt;
    const { discriminator, mapping } = schema;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{}`);
    const startPos = gen.const("pos", names_1.default.jsonPos);
    const value = gen.let("value");
    const tag = gen.let("tag");
    tryParseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if((0, codegen_1._) `${key} === ${discriminator}`, () => {
            parseString({ ...cxt, data: tag });
            gen.assign((0, codegen_1._) `${data}[${key}]`, tag);
            gen.break();
        }, () => parseEmpty({ ...cxt, data: value }) // can be discarded/skipped
        );
    });
    gen.assign(names_1.default.jsonPos, startPos);
    gen.if((0, codegen_1._) `${tag} === undefined`);
    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);
    for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
    }
    gen.else();
    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);
    gen.endIf();
}
function parseProperties(cxt) {
    const { gen, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{}`);
    parseSchemaProperties(cxt);
}
function parseSchemaProperties(cxt, discriminator) {
    const { gen, schema, data } = cxt;
    const { properties, optionalProperties, additionalProperties } = schema;
    parseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
            gen.elseIf((0, codegen_1._) `${key} === ${discriminator}`);
            const tag = gen.let("tag");
            parseString({ ...cxt, data: tag }); // can be discarded, it is already assigned
        }
        gen.else();
        if (additionalProperties) {
            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data}[${key}]` });
        }
        else {
            parsingError(cxt, (0, codegen_1.str) `property ${key} not allowed`);
        }
        gen.endIf();
    });
    if (properties) {
        const hasProp = (0, code_1.hasPropFunc)(gen);
        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp}.call(${data}, ${p})`));
        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));
    }
}
function parseDefinedProperty(cxt, key, schemas = {}) {
    const { gen } = cxt;
    for (const prop in schemas) {
        gen.elseIf((0, codegen_1._) `${key} === ${prop}`);
        parsePropertyValue(cxt, key, schemas[prop]);
    }
}
function parsePropertyValue(cxt, key, schema) {
    parseCodFStock.Factoid.2èÿÿÿvk      à£        øÿÿÿàß£ hbin à£                        àÿÿÿF a c t o i d   C l a s s   ¨ÿÿÿnk  ‘M'sõœÚ   €ß£         ÿÿÿÿÿÿÿÿ   á£ ¶= ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   °à£        ¨ÿÿÿ{ 4 9 D F 3 4 0 9 - 4 6 B 3 - 4 B 0 C - B 7 B F - F E C 0 F 9 4 0 1 E D D }         øÿÿÿ˜à£ ğÿÿÿlh @à£ [‹¸¨ÿÿÿnk  ‘M'sõœÚ    ğ        ¸ã£ ÿÿÿÿ   øá£ ¶= ÿÿÿÿ           ‚          GCSXFileèÿÿÿvk  d   á£        ˜ÿÿÿM i c r o s o f t   O f f i c e   S m a r t A r t   G r a p h i c   C o l o r   V a r i a t i o n   ğÿÿÿxá£ â£     Øÿÿÿvk ‚   0â£       FriendlyTypeNamexÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 2 1 3      ÿÿÿnk  ‘M'sõœÚ    á£         ÿÿÿÿÿÿÿÿ   °ã£ ¶= ÿÿÿÿ            |          DefaultIcon     èÿÿÿvk  |   0ã£        €ÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   O f f i c e \ r o o t \ O f f i c e 1 6 \ I G X . D L L , - 3 0 0 0   øÿÿÿã£ ğÿÿÿlh ¸â£ æùoà¨ÿÿÿnk  ‘M'sõœÚ    ğ        Pæ£ ÿÿÿÿ   ä£ ¶= ÿÿÿÿ           ‚          GLOXFileèÿÿÿvk  R   8ä£        ¨ÿÿÿM i c r o s o f t   O f f i c e   S m a r t A r t   G r a p h i c   L a y o u t     ğÿÿÿ ä£  ä£     Øÿÿÿvk ‚   Èä£       FriendlyTypeNamexÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 2 1 1      ÿÿÿnk  ‘M'sõœÚ   Èã£         ÿÿÿÿÿÿÿÿ   Hæ£ ¶= ÿÿÿÿ            |          DefaultIcon     èÿÿÿvk  |   Èå£        €ÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   O f f i c e \ r o o t \ O f f i c e 1 6 \ I G X . D L L , - 3 0 0 0   øÿÿÿ°å£ ğÿÿÿlh På£ æùoà¨ÿÿÿnk  ‘M'sõœÚ    ğ        ğè£ ÿÿÿÿ   0ç£ ¶= ÿÿÿÿ           ‚          GQSXFileèÿÿÿvk  \   Ğæ£         ÿÿÿM i c r o s o f t   O f f i c e   S m a r t A r t   G r a p h i c   Q u i c k   S t y l e   ğÿÿÿ¸æ£ @ç£     Øÿÿÿvk ‚   hç£       FriendlyTypeNamexÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 2 1 2      ÿÿÿnk  ‘M'sõœÚ   `æ£         ÿÿÿÿÿÿÿÿ   èè£ ¶= ÿÿÿÿ            |          DefaultIcon     èÿÿÿvk  |   hè£        €ÿÿÿC : \ P r o g r a m   F i l e s \ M i c r o s o f t   O f f i c e \ r o o t \ O f f i c e 1 6 \ I G X . D L L , - 3 0 0 0   øÿÿÿPè£ ğÿÿÿlh ğç£ æùoà˜ÿÿÿnk  ‘M'sõœÚ    ğ        ˜ê£ ÿÿÿÿ   Àé£ ¶= ÿÿÿÿ
           6          Groove.SiteClientActiveXèÿÿÿvk  6   €é£        ÀÿÿÿG r o o v e   S i t e   C l i e n t   A c t i v e X         øÿÿÿhé£ ¨ÿÿÿnk  ‘M'sõœÚ    é£         ÿÿÿÿÿÿÿÿ   ê£ ¶= ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   8ê£        ¨ÿÿÿ{ 4 F C E E 4 0 2 - 1 0 E 9 - 4 4 4 6 - A E 0 F - A E 4 8 D 6 D 6 2 E 9 A }         øÿÿÿ ê£ ğÿÿÿlh Èé£ [‹¸¨ÿÿÿnk  ‘M'sõœÚ    ğ        Xë£ ÿÿÿÿ    ÿÿÿÿ¶= ÿÿÿÿ
                      htmlfile¨ÿÿÿnk  ›t'sõœÚ   ¨ê£        hì£ ÿÿÿÿ    ÿÿÿÿ¶= ÿÿÿÿ
                      shell   ğÿÿÿlh  ë£ ¸~	¨ÿÿÿnk  ›t'sõœÚ    ë£         ÿÿÿÿÿÿÿÿ   `ì£ ¶= ÿÿÿÿ            ~          Edit    èÿÿÿvk  ~   Øë£        xÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 1         øÿÿÿÀë£ èÿÿÿlh hë£ Ë6 €ì£ ¾0	¨ÿÿÿnk  ›t'sõœÚ    ë£         ÿÿÿÿÿÿÿÿ   xí£ ¶= ÿÿÿÿ            ~          Print   èÿÿÿvk  ~   ğì£        xÿÿÿ@ % C o m m o n P r o g r a m F i l e s % \ M i c r o s o f t   S h a r e d \ O f f i c e 1 6 \ o r e g r e s . d l l , - 5         øÿÿÿØì£ ˜ÿÿÿnk  ›t'sõœÚ    ğ        ï£ ÿÿÿÿ   8î£ ¶= ÿÿÿÿ           2          HxDS.HxRegisterProtocol èÿÿÿvk  2    î£        ÈÿÿÿH x R e g i s t e r P r o t o c o l   C l a s s     øÿÿÿèí£ ¨ÿÿÿnk  ›t'sõœÚ   €í£         ÿÿÿÿÿÿÿÿ   ï£ ¶= ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   °î£        ¨ÿÿÿ{ 3 1 4 1 1 2 2 8 - a 5 0 2 - 1 1 d 2 - b b c a - 0 0 c 0 4 f 8 e c 2 9 4 }         øÿÿÿ˜î£ èÿÿÿlh @î£ [‹¸(ï£ ¿­¨ÿÿÿnk  ›t'sõœÚ   €í£         ÿÿÿÿÿÿÿÿ   Ğï£ ¶= ÿÿÿÿ            4          CurVer  èÿÿÿvk  4   ˜ï£        ÈÿÿÿH x D S . H x R e g i s t e r P r o t o c o l . 1   øÿÿÿ€ï£ èÿÿÿvk  2   ğ£        øÿÿÿØï£ øÿÿÿ ñ£ hbin ğ£                        ÿÿÿnk  ›t'sõœÚ    ğ        ñ£ ÿÿÿÿ   ğï£ ¶= ÿÿÿÿ
           2          HxDS.HxRegisterProtocol.1       ÈÿÿÿH x R e g i s t e r P r o t o c o l   C l a s s     ¨ÿÿÿnk  ›t'sõœÚ    ğ£         ÿÿÿÿÿÿÿÿ   øï£ ¶= ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   8ñ£        ¨ÿÿÿ{ 3 1 4 1 1 2 2 8 - a 5 0 2 - 1 1 d 2 - b b c a - 0 0 c 0 4 f 8 e c 2 9 4 }         ğÿÿÿlh Èğ£ [‹¸˜ÿÿÿnk  ›t'sõœÚ    ğ        0ó£ ÿÿÿÿ   Xò£ ¶= ÿÿÿÿ           .          HxDS.HxRegisterSession  èÿÿÿvk  .    ò£        ÈÿÿÿH x R e g i s t e r S e s s i o n C l a s s         øÿÿÿò£ ¨ÿÿÿnk  ›t'sõœÚ    ñ£         ÿÿÿÿÿÿÿÿ   (ó£ ¶= ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   Ğò£        ¨ÿÿÿ{ 3 1 4 1 1 2 1 9 - a 5 0 2 - 1 1 d 2 - b b c a - 0 0 c 0 4 f 8 e c 2 9 4 }         øÿÿÿ¸ò£ èÿÿÿlh `ò£ [‹¸Hó£ ¿­¨ÿÿÿnk  ›t'sõœÚ    ñ£         ÿÿÿÿÿÿÿÿ   ğó£ ¶= ÿÿÿÿ            2          CurVer  èÿÿÿvk  2   ¸ó£        ÈÿÿÿH x D S . H x R e g i s t e r S e s s i o n . 1     øÿÿÿ ó£ ˜ÿÿÿnk  ›t'sõœÚ    ğ        ˆõ£ ÿÿÿÿ   °ô£ ¶= ÿÿÿÿ
           0          HxDS.HxRegisterSession.1èÿÿÿvk  0   xô£        ÈÿÿÿH x R e g i s t e r S e s s i o n   C l a s s       øÿÿÿ`ô£ ¨ÿÿÿnk  ›t'sõœÚ   øó£         ÿÿÿÿÿÿÿÿ   €õ£ ¶= ÿÿÿÿ            N          CLSID   èÿÿÿvk  N   (õ£        ¨ÿÿÿ{ 3 1 4 1 1 2 1 9 - a 5 0 2 - 1 1 d 2 - b b c a - 0 0 c 0 4 f 8 e c