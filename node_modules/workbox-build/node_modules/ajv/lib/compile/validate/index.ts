import type {
  AddedKeywordDefinition,
  AnySchema,
  AnySchemaObject,
  KeywordErrorCxt,
  KeywordCxtParams,
} from "../../types"
import type {SchemaCxt, SchemaObjCxt} from ".."
import type {InstanceOptions} from "../../core"
import {boolOrEmptySchema, topBoolOrEmptySchema} from "./boolSchema"
import {coerceAndCheckDataType, getSchemaTypes} from "./dataType"
import {shouldUseGroup, shouldUseRule} from "./applicability"
import {checkDataType, checkDataTypes, reportTypeError, DataType} from "./dataType"
import {assignDefaults} from "./defaults"
import {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from "./keyword"
import {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from "./subschema"
import {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from "../codegen"
import N from "../names"
import {resolveUrl} from "../resolve"
import {
  schemaRefOrVal,
  schemaHasRulesButRef,
  checkUnknownRules,
  checkStrictMode,
  unescapeJsonPointer,
  mergeEvaluated,
} from "../util"
import type {JSONType, Rule, RuleGroup} from "../rules"
import {
  ErrorPaths,
  reportError,
  reportExtraError,
  resetErrorsCount,
  keyword$DataError,
} from "../errors"

// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
export function validateFunctionCode(it: SchemaCxt): void {
  if (isSchemaObj(it)) {
    checkKeywords(it)
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it)
      return
    }
  }
  validateFunction(it, () => topBoolOrEmptySchema(it))
}

function validateFunction(
  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,
  body: Block
): void {
  if (opts.code.es5) {
    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {
      gen.code(_`"use strict"; ${funcSourceUrl(schema, opts)}`)
      destructureValCxtES5(gen, opts)
      gen.code(body)
    })
  } else {
    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>
      gen.code(funcSourceUrl(schema, opts)).code(body)
    )
  }
}

function destructureValCxt(opts: InstanceOptions): Code {
  return _`{${N.instancePath}="", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${
    N.data
  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`
}

function destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {
  gen.if(
    N.valCxt,
    () => {
      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)
      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)
      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)
      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)
      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)
    },
    () => {
      gen.var(N.instancePath, _`""`)
      gen.var(N.parentData, _`undefined`)
      gen.var(N.parentDataProperty, _`undefined`)
      gen.var(N.rootData, N.data)
      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)
    }
  )
}

function topSchemaObjCode(it: SchemaObjCxt): void {
  const {schema, opts, gen} = it
  validateFunction(it, () => {
    if (opts.$comment && schema.$comment) commentKeyword(it)
    checkNoDefault(it)
    gen.let(N.vErrors, null)
    gen.let(N.errors, 0)
    if (opts.unevaluated) resetEvaluated(it)
    typeAndKeywords(it)
    returnResults(it)
  })
  return
}

function resetEvaluated(it: SchemaObjCxt): void {
  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
  const {gen, validateName} = it
  it.evaluated = gen.const("evaluated", _`${validateName}.evaluated`)
  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))
  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))
}

function funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {
  const schId = typeof schema == "object" && schema[opts.schemaId]
  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil
}

// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it: SchemaCxt, valid: Name): void {
  if (isSchemaObj(it)) {
    checkKeywords(it)
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid)
      return
    }
  }
  boolOrEmptySchema(it, valid)
}

function schemaCxtHasRules({schema, self}: SchemaCxt): boolean {
  if (typeof schema == "boolean") return !schema
  for (const key in schema) if (self.RULES.all[key]) return true
  return false
}

function isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {
  return typeof it.schema != "boolean"
}

function subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {
  const {schema, gen, opts} = it
  if (opts.$comment && schema.$comment) commentKeyword(it)
  updateContext(it)
  checkAsyncSchema(it)
  const errsCount = gen.const("_errs", N.errors)
  typeAndKeywords(it, errsCount)
  // TODO var
  gen.var(valid, _`${errsCount} === ${N.errors}`)
}

function checkKeywords(it: SchemaObjCxt): void {
  checkUnknownRules(it)
  checkRefsAndKeywords(it)
}

function typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {
  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)
  const types = getSchemaTypes(it.schema)
  const checkedTypes = coerceAndCheckDataType(it, types)
  schemaKeywords(it, types, !checkedTypes, errsCount)
}

function checkRefsAndKeywords(it: SchemaObjCxt): void {
  const {schema, errSchemaPath, opts, self} = it
  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {
    self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`)
  }
}

function checkNoDefault(it: SchemaObjCxt): void {
  const {schema, opts} = it
  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
    checkStrictMode(it, "default is ignored in the schema root")
  }
}

function updateContext(it: SchemaObjCxt): void {
  const schId = it.schema[it.opts.schemaId]
  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)
}

function checkAsyncSchema(it: SchemaObjCxt): void {
  if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema")
}

function commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {
  const msg = schema.$comment
  if (opts.$comment === true) {
    gen.code(_`${N.self}.logger.log(${msg})`)
  } else if (typeof opts.$comment == "function") {
    const schemaPath = str`${errSchemaPath}/$comment`
    const rootName = gen.scopeValue("root", {ref: schemaEnv.root})
    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)
  }
}

function returnResults(it: SchemaCxt): void {
  const {gen, schemaEnv, validateName, ValidationError, opts} = it
  if (schemaEnv.$async) {
    // TODO assign unevaluated
    gen.if(
      _`${N.errors} === 0`,
      () => gen.return(N.data),
      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)
    )
  } else {
    gen.assign(_`${validateName}.errors`, N.vErrors)
    if (opts.unevaluated) assignEvaluated(it)
    gen.return(_`${N.errors} === 0`)
  }
}

function assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {
  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)
  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)
}

function schemaKeywords(
  it: SchemaObjCxt,
  types: JSONType[],
  typeErrors: boolean,
  errsCount?: Name
): void {
  const {gen, schema, data, allErrors, opts, self} = it
  const {RULES} = self
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {
    gen.block(() => keywordCode(it, "$ref", (RULES.all.$ref as Rule).definition)) // TODO typecast
    return
  }
  if (!opts.jtd) checkStrictTypes(it, types)
  gen.block(() => {
    for (const group of RULES.rules) groupKeywords(group)
    groupKeywords(RULES.post)
  })

  function groupKeywords(group: RuleGroup): void {
    if (!shouldUseGroup(schema, group)) return
    if (group.type) {
      gen.if(checkDataType(group.type, data, opts.strictNumbers))
      iterateKeywords(it, group)
      if (types.length === 1 && types[0] === group.type && typeErrors) {
        gen.else()
        reportTypeError(it)
      }
      gen.endIf()
    } else {
      iterateKeywords(it, group)
    }
    // TODO make it "ok" call?
    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)
  }
}

function iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {
  const {
    gen,
    schema,
    opts: {useDefaults},
  } = it
  if (useDefaults) assignDefaults(it, group.type)
  gen.block(() => {
    for (const rule of group.rules) {
      if (shouldUseRule(schema, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type)
      }
    }
  })
}

function checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {
  if (it.schemaEnv.meta || !it.opts.strictTypes) return
  checkContextTypes(it, types)
  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)
  checkKeywordTypes(it, it.dataTypes)
}

function checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {
  if (!types.length) return
  if (!it.dataTypes.length) {
    it.dataTypes = types
    return
  }
  types.forEach((t) => {
    if (!includesType(it.dataTypes, t)) {
      strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`)
    }
  })
  narrowSchemaTypes(it, types)
}

function checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword")
  }
}

function checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {
  const rules = it.self.RULES.all
  for (const keyword in rules) {
    const rule = rules[keyword]
    if (typeof rule == "object" && shouldUseRule(it.schema, rule)) {
      const {type} = rule.definition
      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
        strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`)
      }
    }
  }
}

function hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {
  return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"))
}

function includesType(ts: JSONType[], t: JSONType): boolean {
  return ts.includes(t) || (t === "integer" && ts.includes("number"))
}

function narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {
  const ts: JSONType[] = []
  for (const t of it.dataTypes) {
    if (includesType(withTypes, t)) ts.push(t)
    else if (withTypes.includes("integer") && t === "number") ts.push("integer")
  }
  it.dataTypes = ts
}

function strictTypesError(it: SchemaObjCxt, msg: string): void {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath
  msg += ` at "${schemaPath}" (strictTypes)`
  checkStrictMode(it, msg, it.opts.strictTypes)
}

export class KeywordCxt implements KeywordErrorCxt {
  readonly gen: CodeGen
  readonly allErrors?: boolean
  readonly keyword: string
  readonly data: Name // Name referencing the current level of the data instance
  readonly $data?: string | false
  schema: any // keyword value in the schema
  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value
  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)
  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema
  readonly parentSchema: AnySchemaObject
  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,
  // requires option trackErrors in keyword definition
  params: KeywordCxtParams // object to pass parameters to error messages from keyword code
  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)
  readonly def: AddedKeywordDefinition

  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {
    validateKeywordUsage(it, def, keyword)
    this.gen = it.gen
    this.allErrors = it.allErrors
    this.keyword = keøÿÿÿ¨OÎèÿÿÿlh HOÎÜt PÎüC¶»øÿÿÿ€PÎøÿÿÿhQÎhbin PÎ                        ÿÿÿnk  OÔïÅÚ   €NÎ        ÿÿÿÿÿÿÿÿ   ğOÎQ  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ˜PÎ     s ¨ÿÿÿ{ B B E E 8 8 4 8 - 8 5 9 1 - 4 6 8 B - B B 0 4 - 1 0 E 9 B F 4 7 9 C D B }     nk  ˆÿÿÿnk  ğÈÛŞ¬Õ   ğÎ<        ÈRÎÿÿÿÿ   øOÎ@\  ÿÿÿÿ            l       &   {88FE2FBA-AF65-5BB9-B417-19C76803F487}  èÿÿÿvk  l   €QÎ       ÿÿÿ_ _ x _ W i n d o w s _ C D e v i c e s _ C D i s p l a y _ C C o r e _ C I D i s p l a y M a n a g e r 2    ÿÿÿnk  ğÈÛŞ¬Õ   ğPÎ        ÿÿÿÿÿÿÿÿ   ÀRÎ@\  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   hRÎ       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿPRÎğÿÿÿlh ğQÎüC¶»ˆÿÿÿnk  Ÿ”MŠÚ   ğÎ<        €TÎÿÿÿÿ    SÎğ  ÿÿÿÿ            .       &   {88FF5F69-FACF-4667-8DC8-A85B8225DF15}  èÿÿÿvk  .   hSÎ       ÈÿÿÿS e n s i t i v i t y L a b e l P o l i c y         øÿÿÿPSÎ ÿÿÿnk  Ü”MŠÚ   ØRÎ        ÿÿÿÿÿÿÿÿ   xTÎğ  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    TÎ       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿTÎèÿÿÿlh ¨SÎüC¶»˜TÎ×§¨ÿÿÿnk  Ÿ”MŠÚ   ØRÎ        ÿÿÿÿÿÿÿÿ   `UÎğ  ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   UÎ       ¨ÿÿÿ{ 2 D F 8 D 0 4 C - 5 B F A - 1 0 1 B - B D E 5 - 0 0 A A 0 0 4 4 D E 5 2 }         ğÿÿÿğTÎpUÎ    àÿÿÿvk    UÎ      Version ğÿÿÿ2 . 8       ˆÿÿÿnk  ªúÖÚ   ğÎ<        ğVÎÿÿÿÿ   hVÎ˜  ÿÿÿÿ            0       &   {88FFEA2B-3A8F-4DAB-8043-D1D8292C6939}  èÿÿÿvk  0   0VÎ      ÈÿÿÿI D e b u g M a r s h a l l e d O b j e c t 2       øÿÿÿVÎ ÿÿÿnk  ªúÖÚ    UÎ        ÿÿÿÿÿÿÿÿ   èVÎQ  ÿÿÿÿ                   
   NumMethods~°”~èÿÿÿvk    €4        i øÿÿÿĞVÎèÿÿÿlh pVÎÜtWÎüC¶» ÿÿÿnk  YB÷0ß¬Õ    UÎ        ÿÿÿÿÿÿÿÿ   ØWÎ˜  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   €WÎ       ¨ÿÿÿ{ C 5 6 2 1 3 6 4 - 8 7 C C - 4 7 3 1 - 8 9 4 7 - 9 2 9 C A E 7 5 3 2 3 E }         øÿÿÿhWÎˆÿÿÿnk  şÿlKŠÚ   ğÎ<        0YÎÿÿÿÿ   ˜XÎQ  ÿÿÿÿ                   &   {890ED3DC-CC19-43FA-8EBF-BAECB6B9EC87}Íèÿÿÿvk     pXÎ     t"ØÿÿÿI V i r t u a l B o x S D S   [‡L¼føÿÿÿXXÎ ÿÿÿnk  şÿlKŠÚ   àWÎ        ÿÿÿÿÿÿÿÿ   (YÎQ  ÿÿÿÿ                   
   NumMethods\«¹‘èÿÿÿvk     YÎ     \ğÿÿÿ1 0   q×§øÿÿÿ YÎàÿÿÿlh  XÎÜtPYÎüC¶»(ZÎ×§ ÿÿÿnk  şÿlKŠÚ   àWÎ        ÿÿÿÿÿÿÿÿ    ZÎQ  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ÈYÎ     §¨ÿÿÿ{ 0 B B 3 B 7 8 C - 1 8 0 7 - 4 2 4 9 - 5 B A 5 - E A 4 2 D 6 6 A F 0 B F }   \­¹óTøÿÿÿ°YÎ¨ÿÿÿnk  şÿlKŠÚ   àWÎ        ÿÿÿÿÿÿÿÿ   ğZÎQ  ÿÿÿÿ           N          TypeLibŠèÿÿÿvk  N   ˜ZÎ     =¶¨ÿÿÿ{ D 7 5 6 9 3 5 1 - 1 7 5 0 - 4 6 F 0 - 9 3 6 E - B D 1 2 7 D 5 B C 2 6 4 }   \aÎ÷Hğÿÿÿ€ZÎ [Î    àÿÿÿvk     [Î    ¨qVersion§ğÿÿÿ1 . 3   ªÂó¯ˆÿÿÿnk  YB÷0ß¬Õ   ğÎ<         ]Îÿÿÿÿ   @\Î˜  ÿÿÿÿ            z       &   {89135CFF-28B8-46AA-B137-1C4B0F21EDFE}  èÿÿÿvk  z   À[Î       €ÿÿÿI M o b i l e B r o a d b a n d N e t w o r k R e g i s t r a t i o n S t a t e C h a n g e T r i g g e r D e t a i l s     øÿÿÿ¨[Î ÿÿÿnk  YB÷0ß¬Õ   0[Î        ÿÿÿÿÿÿÿÿ   ]Î˜  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   À\Î     Ë¨ÿÿÿ{ 8 B D C E 7 3 5 - A 0 7 7 - 4 0 6 B - B 5 2 6 - F 1 4 6 5 D D 4 D 3 5 C }         øÿÿÿ¨\Îğÿÿÿlh H\ÎüC¶»ˆÿÿÿnk  ğÈÛŞ¬Õ   ğÎ<        È^Îÿÿÿÿ   è]Î@\  ÿÿÿÿ            $       &   {8918eee6-f28c-4a63-895b-a24341042ac6}  èÿÿÿvk  $   À]Î      ØÿÿÿI D i c t a t i o n M a n a g e r   øÿÿÿ¨]Î ÿÿÿnk  ğÈÛŞ¬Õ   0]Î        ÿÿÿÿÿÿÿÿ   À^Î@\  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   h^Î       ¨ÿÿÿ{ F 6 E F E A B D - 3 3 7 0 - 4 A A 0 - A 4 F D - 8 8 B A D C 3 B 1 A 3 9 }         øÿÿÿP^Îğÿÿÿlh ğ]ÎüC¶»ˆÿÿÿnk  2—yä¬Õ   ğÎ<        Ğ_Îÿÿÿÿ    ÿÿÿÿ@\  ÿÿÿÿ                    &   {891bddde-6bf3-5d1f-80ab-5a342a16a0bb}   ÿÿÿnk  2—yä¬Õ   Ø^Î        ÿÿÿÿÿÿÿÿ   È_Îx• ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    `Î     Ëøÿÿÿ°_Îğÿÿÿlh P_ÎüC¶»èÿÿÿvk     ğ`Î     8 øÿÿÿà_Îhbin `Î                       ¨ÿÿÿ{ 0 b 4 c 2 2 7 f - 2 3 9 4 - 4 3 f f - b a 5 9 - b c 7 6 2 f 5 c 4 6 e a }         ˆÿÿÿnk  2—yä¬Õ   ğÎ<        èaÎÿÿÿÿ   ø_Î@\  ÿÿÿÿ                   &   {891EADB1-1C45-48B0-B704-49A888DA98C4}  àÿÿÿI T a s k C n t r C t r l    ÿÿÿnk  2—yä¬Õ   x`Î        ÿÿÿÿÿÿÿÿ   àaÎx• ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N   ˆaÎ       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }   Î 8 øÿÿÿpaÎàÿÿÿlh aÎc#¡bÎüC¶»àbÎ×§ ÿÿÿnk  2—yä¬Õ   x`Î        ÿÿÿÿÿÿÿÿ   ØbÎx• ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   €bÎ      ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }        øÿÿÿhbÎ¨ÿÿÿnk  2—yä¬Õ   x`Î        ÿÿÿÿÿÿÿÿ   ¨cÎx• ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   PcÎ      ¨ÿÿÿ{ 6 B F 5 2 A 5 0 - 3 9 4 A - 1 1 D 3 - B 1 5 3 - 0 0 C 0 4 F 7 9 F A A 6 }   #mW wnğÿÿÿ8cÎ¸cÎ    àÿÿÿvk    ØcÎ      VersionËğÿÿÿ1 . 0     ˆÿÿÿnk  ğÈÛŞ¬Õ   ğÎ<        €eÎÿÿÿÿ    dÎ@\  ÿÿÿÿ            "       &   {89215167-8CEE-436D-89AB-8DFB43BB4286}  èÿÿÿvk  "   xdÎ       ØÿÿÿI B a r c o d e S c a n n e r 2     øÿÿÿ`dÎ ÿÿÿnk  ğÈÛŞ¬Õ   ècÎ        ÿÿÿÿÿÿÿÿ   xeÎx• ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    eÎ       ¨ÿÿÿ{ E 1 B A 8 8 B A - 7 A 8 3 - 4 2 1 A - A 0 5 D - 7 1 F 9 6 C 3 F F F D 0 }         øÿÿÿeÎğÿÿÿlh ¨dÎüC¶»ˆÿÿÿnk  ğÈÛŞ¬Õ   ğÎ<        ĞgÎÿÿÿÿ   ğfÎ@\  ÿÿÿÿ            Æ       &   {89248EFA-A247-5ACF-93F3-2CB7D44DD260}  èÿÿÿvk  Æ    fÎ       0ÿÿÿ_ _ F I T y p e d E v e n t H a n d l e r _ 2 _ W i n d o w s _ _ C U I _ _ C C o r e _ _ C I C o m p o n e n t F o c u s _ W i n d o w s _ _ C U I _ _ C C o r e _ _ C F o c u s E v e n t A r g s         øÿÿÿfÎ ÿÿÿnk  ğÈÛŞ¬Õ   eÎ        ÿÿÿÿÿÿÿÿ   ÈgÎ@\  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   pgÎ       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿXgÎğÿÿÿlh øfÎüC¶»ˆÿÿÿnk  ğÈÛŞ¬Õ   ğÎ<        ğiÎÿÿÿÿ   iÎ@\  ÿÿÿÿ            š       &   {89258618-1FC4-5551-9343-E51C5F420551}  èÿÿÿvk  š   phÎ       `ÿÿÿ_ _ F I V e c t o r _ 1 _ W i n d o w s _ _ C A p p l i c a t i o n M o d e l _ _ C U s e r D a t a A c c o u n t s _ _ C U s e r D a t a A c c o u n t     øÿÿÿXhÎ ÿÿÿnk  ğÈÛŞ¬Õ   àgÎ        ÿÿÿÿÿÿÿÿ   èiÎ@\  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   iÎ      ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿxiÎğÿÿÿlh iÎüC¶»ˆÿÿÿnk  ğÈÛŞ¬Õ   ğÎ<        ğkÎÿÿÿÿ   kÎ@\  ÿÿÿÿ            v       &   {8928d527-db5d-5a10-ae9b-430fa0906e74}  èÿÿÿvk  v   jÎ       €ÿÿÿI I t e r a b l e _ 1 _ W i n d o w s _ _ C U I _ _ C N o t i f i c a t i o n s _ _ C T o a s t C o l l e c t i o n         øÿÿÿxjÎ ÿÿÿnk  ğÈÛŞ¬Õ    jÎ        ÿÿÿÿÿÿÿÿ   èkÎx• ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   kÎ       ¨ÿÿÿ{ 6 d b 7 c d 5 2 - e 3 b 7 - 4 e c c - b b 1 f -